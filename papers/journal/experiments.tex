%\externaldocument{sat-table}

%We have developed four different tools (\sattool, \smttool, \qbftool, \ourtool) for implementation of proposed encodings.
%
We have developed the {\vtstool} tool to conjecture the properties of the VTS (explained in Section 6). 
%
%
The {\vtstool} tool includes about 10,000 lines of code.
%
The tool is divided into three different blocks,
%
checking existential condition, checking the universal condition and performing synthesis on the incomplete VTS. 
%
The existential condition is subdivided into two sub-block, using bounded model checking and using constraint solving. 
%
We will refer to existential subblocks as {\sattool} and {\smttool}, universal block as {\qbftool} and synthesis block as {\ourtool}.
%


\subsection{Implementation}
{\sattool} is based on the architecture of a Bounded model checker (CBMC) and uses an enumeration of paths for encoding the reachability problem.
%
{\smttool} is based on the SMT solver Z3 and uses the efficient encoding of finding a least fixed point to solve reachability problem. 
%
{\qbftool} is based on the QBF encoding of the universal condition and uses {\depqbf} solver to solve the generated QBF. 
%
The {\ourtool} is a synthesis tool for synthesizing incomplete information in the input VTS using {\qbftool}.
%
All the experiments were done on a machine with  Intel(R) Core(TM) i7-2600 CPU @ 3.40GHz processor and 16GB RAM with 30 min (1800 sec) timeout.

%\input{sat-table}

%\input{tab:satqbf-grabh}
%\ExecuteMetaData[result-table.tex]{tab:satqbf-grabh}

\textbf{{\sattool} (Bounded model checker based tool)}:
	We have implemented the encodings for different variants of VTS (presented in section 6.2) using CBMC, a Bounded Model Checker, for C and C++ programs. 
%
%Unlike a general model checker~\cite{cimatti2002nusmv}, CBMC
%
The tool verify property for all the possible states, only up to a certain “depth,” a parametric limit on the size of the model.
%
The depth of model is specified by the user and can be  incrementally increased to a desired value.
%
The CBMC architecture consists of a C-language front-end (CFE) and a SAT Solver back-end (SAT). 
%
CBMC front end accepts ANSI-C programs with some special annotations (called assumes and assertions) to express constraints on the model and properties to be checked. 
%	
\todo{SA: CBMC Diagram}	
In our experiments, the vesicle transport network was modelled as a non-deterministic C-program manipulating a graph with labelled edges with the fusion rules and steady state properties expressed as constraints using assumes. 
%		
The correspondence relationship between connectedness conditions
and guarantees for steady state were expressed as assertions to be checked. 
%		
Given an exploration depth provided by the user, which in our case corresponds to the size of the graph, {\sattool} verifies the properties by executing the following steps:
	\begin{itemize}
	\item Convert (using CFE) the model and the properties into a Boolean formula (verification condition) such that the property is true of all behaviors of the model up to the specified
depth iff the Boolean formula is valid.
	\item Check (using a SAT solver) validity of the verification condition. {\sattool} reports successful verification if the formula is found to be valid. If not, then {\sattool} produces a counterexample,
an assignment to the variables of the model, that is a witness to the violation of the property.
	\end{itemize}
For our experimentation purpose, the SAT solver backend used were MiniSat~\cite{sorensson2005minisat}, and CryptoMiniSat~\cite{soos2016cryptominisat}, the winner of SAT 2015 Competition~\cite{balyo2016sat}. 

%CBMC has a built-in SAT solver called MiniSat~\cite{sorensson2005minisat}, but it is also possible to use various other SAT solver blackboxes for property verification. Besides using MiniSat as a default SAT solver for our model, we have used different SAT solvers for the verification of the property, particularly CryptoMiniSat~\cite{soos2016cryptominisat} which was the winner of SAT 2015 Competition~\cite{balyo2016sat}. 
%		MiniSat performed satisfactorily in comparison to other SAT solvers.

\textbf{{\smttool} (SMT based tool)}:
	We have implemented the encodings for each variants (presented in section 6.1) using the python interface of Z3 in a tool {\smttool}. 
%
The tool allows the user to choose a model and the size
of the network besides other parameters like connectivity and number of parallel edges. 
%		
It uses Z3 Python interface to build the needed constraints and applies Z3 solver on the constraints to find a model (a satisfying assignment that respects the constraints). 
%
This tool also translates the satisfying model found by Z3 into
a VTS and represent a visual output to the user in form of coloured annotated graph. 
%
%We also visually report the dropped edges required to disconnect the graph, it gives information about the connectivity of the graph.
%
 

\textbf{{\qbftool} (QBF based universal condition):}
{\qbftool} is developed in C++ and uses~\zthree~\cite{z3} infrastructure and implement the encodings of the VTS in QBF form (presented in section 6.5). 
%
Since some of the formulas involve alternation of quantifiers over
Boolean variables Z3 is not a suitable choice for those examples.
%
We translate the formulas created by Z3 tool into a standard
QDIMACS~\cite{qdimacs} format and use it as an input for QBF solvers. 
%
We have used~\depqbf~\cite{lonsing2010depqbf} for solving the QBF formulas. 

\textbf{{\ourtool} (QBF based synthesis tool):}

\input{synth-table}
We have implemented the synthesis encodings (presented in section 6.6) in a tool
called~\ourtool\footnote{{\url{https://github.com/arey0pushpa/pyZ3}}}.
%
The tool takes a partially defined VTS as input in a custom designed
input language.
%
The input is then converted to the constraints over VTS using the {\qbftool} interface. 
%
The tool can not only synthesize the discussed queries, but also their
combinations.
%
For example, our tool can modify labels of nodes or edges while
learning activity functions.


\subsection{Results}
The results and timings of three blocks of the {\vtstool} are presented in the table~\ref{tab:smt-grph}, for both {\sattool} and {\smttool}, in table~\ref{tab:qbf-graph} for {\sattool} and in table~\ref{tab:synth-graph} for~{\ourtool}.


%To illustrate usability of our tool in the last column of the Table~\ref{tab:smt-grph}, we present the minimum connectedness needed for the different variants after applying our tool for sizes from 2 to 10. 
%%
%We found no graph for the variant A with constraints Ann and Aen. 
%%
%Replacing constraint on the node of Ann with Anb (variant B)
%does not affect the outcome. 
%%
%If we allow every present molecule to stay active
%(Ann) but constraint the edge by a boolean function (Aeb) the resultant VTS has to be at least 3-connected. 
%%
%Similarly, the results for other cases are presented in the table.

\input{smt-table}

In Table~\ref{tab:smt-grph}, we present the running times for the search of
VTSs for {\smttool} of sizes 2 to 10 that satisfy the variants and compare with the {\sattool}.
%
For the comparison between both encodings we have fixed the total
number of molecules to be $|M| = 2|N|$ for $ |N|> 2$ and $|M| = 2|N| + 1$ for $|N| = 2$.
%
For each variant, we fix maximum number of parallel
edges to 2.
%
In the table we have shown comparison for specific connectivity, for
example variant A is checked against any graph with connectivity 2,
variant B with connectivity 3 similarly for the rest of the Variants.
%

%We have compared our performance with the performance of our earlier CBMC based implementation (old-encoding).
%
For example, the formula for variation F, the total number of
compartments ($|N|$) equals to 10, returns in 129.78 minutes (7786.8 s
ecs)
with a SAT result.
%
In comparison, CBMC results in OUT OF MEMORY for $|N|$ greater than 5.
%
``!'' indicate that the constraints were unsatisfiable.
%
Using this encoding in comparison to the old one, not only we got effi
ciency improved for finding a SAT model but also did better in the cas
e of refutation that no model exist (Table 2 Variant A timing comparis
on and Variant D with N =2). 
%
Hence with the use of this novel encoding, we are able to scale the system to a much larger compartmentalized system, especially to
eukaryotic cells with a total number of 10 compartments.
%
Furthermore, we experimented with limits of our tools and found
that $\zthree$ was able to solve the constraints up to $\sim{14-18}$ n
odes.

\input{qbf-table}
%\textbf{Universal Condition:}
Table~\ref{tab:qbf-graph} presents the result of the QBF tool.

%\textbf{Synthesis}:

We have applied~\ourtool~on six partially defined VTSs.
%
The results are presented in Fig~\ref{tab:synth-graph} for both the solvers
\depqbf and \zthree.
%
To use~\zthree, we remove \texttt{Connected} constraints, such that the queries becomes
quantifier-free.
%
% The experiments were conducted on a machine,
% with \ashu{?}MHz processor, \ashu{?}GB memory, and 900s timeout.
%
%The experiments were conducted with a 900s timeout.
%
The first four VTSs are synthetic but inspire from literature for
typical motifs in VTSs. 
The third VTS is a subgraph of the last VTS.
%
%
The fifth VTS is taken from~\cite{burri2004complete}.
%
The last VTS represent mammalian SNARE map created by studying the literature references.  

The table shows timing for various synthesis queries.
%
For each synthesis query, we have two columns.
%
One column reports the timing and the other reports the minimum changes
needed to obtain a valid VTS.
%
$\infty$ indicates that any number of changes with the synthesis query
search space can obtain the VTS.
%
%\ashu{@ankit: please discuss all the synthesis queries in the table.}
In the table, we are reporting five synthesis queries
%
The first one only adds new labelled edges to the graph.
%
We have ranked the all possible graph edits with the simple rank of
minimum updates.
% %
% Our tools were able to complete the graphs by adding five new edges
% and nine new molecules in 210s.
%
The second query adds new labels to the edge.
%  and was able to
% fix the graphs with eleven new molecule labels in 180s.
%
The third query synthesizes NNF Boolean functions only containing
$\land$ and $\lor$ gates for activity functions, while allowing
more edges to be added.
%
The result shows the basic template of 4 leaves and 3 gates.
%
% The tool was able to synthesize the Boolean functions in 470s.
%
To illustrate the versatility of our tool, the fourth query
synthesizes $3$-CNF functions (encoding not presented).
%  and was able to
% synthesis the results for all graphs in 500s.
%
Finally, we report queries that allows both addition and deletion of edges, and labels
of node and labels. 

%
%Our experiments suggest that the synthesis problems are solvable by modern 
%solvers and the synthesis technology may be useful for biological research.
%

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
