%\externaldocument{sat-table}

%We have developed four different tools (\sattool, \smttool, \qbftool, \ourtool) for implementation of proposed encodings.
%
We have developed the {\vtstool} tool to conjecture the properties of the VTS (explained in Section 6). 
%
%
The {\vtstool} tool includes about 10,000 lines of code.
%
The tool is divided into three different blocks,
%
checking existential condition, checking the universal condition and performing synthesis on the incomplete VTS. 
%
The existential condition is subdivided into two sub-block, bounded model checking and constraint solving. 
%
We will refer to existential subblocks as {\sattool} and {\smttool}, universal block as {\qbftool} and synthesis block as {\ourtool}.
%


\subsection{Implementation}
%The existential condition problem is implemented with two separate encodings.
We have implemented two separate encodings to determine the existential condition of the VTS. 
%To solve the existential condition we have implemented two separate encodings. 
%
The first encoding is implemented in {\sattool}
%One 
%with a successful bounded model checker, CBMC, 
and perform path enumeration to encode the reachability. 
%
%This encoding is implemented in {\sattool}.
% and uses a successful bounded model checker, CBMC.
%which is based on the architecture of a
%
%The second encoding is implemented in {\smttool} and uses a
%is based on 
%industrial strength SMT solver, Z3, that uses a 
%recursive encoding of finding a least fixed point to encode the same. 
The second encoding is implemented in {\smttool} and employs a recursive encoding of finding a least fixed point for the reachability. 

%
%The encoding is implemented in {\smttool}.
% and uses industrial strength SMT solver, Z3.
%The {\sattool} is based on the architecture of a bounded model checker (CBMC) and uses an enumeration of paths for encoding the reachability problem.
%
%The {\smttool} is based on the SMT solver Z3 and uses the efficient encoding of finding a least fixed point to solve reachability problem. 
%
%The {\qbftool} is based on the QBF encoding of the universal condition and uses {\depqbf} solver to solve the generated QBF. 
The QBF encoding of the universal condition is implemented in {\qbftool}.
%
The tool uses {\depqbf} solver to solve the generated QBF formula. 
%
The {\ourtool} is a synthesis tool for synthesizing incomplete information in the input VTS using {\qbftool} interface.
%

All the experiments were done
%Each test was run 
on a machine with Intel(R) Core(TM) i7-2600 CPU @ 3.40GHz processor and 16GB RAM.
%
A 30 min (1800 sec) timeout was used for the tool.

%\input{sat-table}

%\input{tab:satqbf-grabh}
%\ExecuteMetaData[result-table.tex]{tab:satqbf-grabh}

\textbf{{\sattool} (bounded model checker based tool)}:
The enumeration encoding (presented in section 6.2) for each variants of VTS is implemented in {\sattool}.
	%We have implemented the encodings for different variants of VTS (presented in section 6.2) using
The tool is based on CBMC, a successful bounded model checker, for C and C++ programs. 
%
%Unlike a general model checker~\cite{cimatti2002nusmv}, CBMC
%
It verify property for all the possible states, up to a certain “depth,” a parametric limit on the size of the model.
%
The depth of model is specified by the user and can be  incrementally increased to a desired value.
%
%The CBMC architecture consists of a C-language front-end (CFE) and a SAT Solver back-end (SAT). 
%
%CBMC front end accepts 

%We encode the problem using CBMC C-language front-end (CFE) interface with some special annotations called \textit{assumes} and \textit{assertions}.
%
%These annotations express constraints on the model and properties to be checked. 
%	
The vesicle transport network was modelled as a non-deterministic C-program manipulating an annotated graph. 
%
The special annotations \textit{assumes} and \textit{assertions} of CBMC's front end were used to express constraints on the model and properties to be checked. 
%
%The fusion rules and steady state properties were expressed as constraints using special annotations \textit{assumes}. 
%		
%The correspondence relationship between connectedness conditions and steady state were expressed as annotations \textit{assertions} to be checked. 
Using the tool's interface user can select the variation of the VTS, connectivity of the graph and other required parameters like an exploration depth.
%
The {\sattool} verifies the properties by first converting the constraints and properties into a Boolean formula and determine the satisfiability of the formula with the help of a SAT solver backend.
%
The satisfying model is translated into a readable format and in case of a violation, the tool produces a readable counterexample.
%  following steps:
%	\begin{itemize}
%	\item Convert (using CFE) the model and the properties into a Boolean formula (verification condition) such that the property is true of all behaviors of the model up to the specified
%depth iff the Boolean formula is valid.
%	\item Check (using a SAT solver) validity of the verification condition. {\sattool} reports successful verification if the formula is found to be valid. If not, then {\sattool} produces a counterexample,
%an assignment to the variables of the model, that is a witness to the violation of the property.
%	\end{itemize}
For our experimentation purpose, the SAT solver backend used were MiniSat~\cite{sorensson2005minisat}, and CryptoMiniSat~\cite{soos2016cryptominisat}, the winner of SAT 2015 Competition~\cite{balyo2016sat}. 

%CBMC has a built-in SAT solver called MiniSat~\cite{sorensson2005minisat}, but it is also possible to use various other SAT solver blackboxes for property verification. Besides using MiniSat as a default SAT solver for our model, we have used different SAT solvers for the verification of the property, particularly CryptoMiniSat~\cite{soos2016cryptominisat} which was the winner of SAT 2015 Competition~\cite{balyo2016sat}. 
%		MiniSat performed satisfactorily in comparison to other SAT solvers.

\textbf{{\smttool} (SMT based tool)}:
The recursive encoding (presented in section 6.1)  
%We have implemented the encodings 
for each variant is implemented in {\smttool}.
%
It used python interface of industrial strength SMT solver, Z3. 
%
The tool allows the user to choose a model and the size
of the network besides other parameters like connectivity and number of parallel edges. 
%		
It uses Z3 Python interface to build the needed constraints and applies Z3 solver on the constraints to find a model (a satisfying assignment that respects the constraints). 
%
This tool also translates the satisfying model found by Z3 into
a VTS and represent a visual output to the user in form of coloured annotated graph. 
%
%We also visually report the dropped edges required to disconnect the graph, it gives information about the connectivity of the graph.
%
 

\textbf{{\qbftool} (QBF based universal condition):}
We have implemented the encodings of the VTS in QBF form (presented in section 6.5) in
{\qbftool}. 
%
The tool is developed in C++ and uses~\zthree~\cite{z3} infrastructure to encode the constraints.
%
Since some of the formulas involve alternation of quantifiers over Boolean variables Z3 is not a suitable choice for those examples.
%
We translate the formulas created by Z3 tool into a standard
QDIMACS~\cite{qdimacs} format and use it as an input for QBF solvers. 
%
We have used~\depqbf~\cite{lonsing2010depqbf} for solving the QBF formulas. 

\textbf{{\ourtool} (QBF based synthesis tool):}
\input{synth-table}
We have implemented the synthesis encodings (presented in section 6.6) in
called~\ourtool\footnote{{\url{https://github.com/arey0pushpa/pyZ3}}}.
%
The tool takes a partially defined VTS as input in a custom designed
input language.
%
The input is then converted to the constraints over VTS using the {\qbftool} interface. 
%
The tool can not only synthesize the discussed queries, but also their
combinations.
%
For example, our tool can modify labels of nodes or edges while
learning activity functions.
%
The tool returns a complete VTS with visual graph representation as an output to the user.  

\subsection{Results}
The results and timings of three blocks of the {\vtstool} are presented in the table~\ref{tab:smt-grph} and table~\ref{tab:satsmt-graph}, for both {\sattool} and {\smttool}, in table~\ref{tab:qbf-graph} for {\sattool} and in table~\ref{tab:synth-graph} for~{\ourtool}.


%To illustrate usability of our tool in the last column of the Table~\ref{tab:smt-grph}, we present the minimum connectedness needed for the different variants after applying our tool for sizes from 2 to 10. 
%%
%We found no graph for the variant A with constraints Ann and Aen. 
%%
%Replacing constraint on the node of Ann with Anb (variant B)
%does not affect the outcome. 
%%
%If we allow every present molecule to stay active
%(Ann) but constraint the edge by a boolean function (Aeb) the resultant VTS has to be at least 3-connected. 
%%
%Similarly, the results for other cases are presented in the table.

\input{smt-table}

The minimal connectivity results for each variation of the existential condition is presented in table~\ref{tab:smt-grph}.
%
Table~\ref{tab:satsmt-graph} presents the comparison of the running times of {\smttool} and {\sattool} on VTS variations of sizes 2 to 10.
%
For this comparison we have fixed the total number of molecules ($|M|$) to be $2|N|$ 
%for $ |N|> 2$ and $2|N| + 1$ for $|N| = 2$
%
%For each variant, we fix 1
and maximum number of parallel
edges to be 2.
%
%
In the table ``!'' indicate that no model exists for the constraint  (constraints were unsatisfiable).
%In the table we have shown comparison for specific connectivity, for example variant A is checked against any graph with connectivity 2, variant B with connectivity 3 similarly for the rest of the variants.
%
%We have compared our performance with the performance of our earlier CBMC based implementation (old-encoding).
%
As an example, the result of verifying the formula for variation F of 2-connected, 10 compartment graph took 129.78 minutes (7786.8 secs) with a satisfying result.
%
In comparison, {\sattool} was unable to solve the instance and ran OUT OF MEMORY.
% for $|N|$ greater than 5.
%
% 
The recursive encoding also performed better for the cases where the instance was unsatisfiable (table~\ref{tab:satsmt-graph} Variant A timing comparison and Variant D with N =2).
%instead of enumeration, not only we got efficiency improved for finding a SAT model but also did better in the case of refutation that no model exist (table~\ref{tab:satsmt-graph} Variant A timing comparison and Variant D with N =2). 
%
Hence with the use of improved encoding of reachability, we were able to scale the system to the biologically relevant compartment size, the
%a much larger compartmentalized system, especially to interesting 
the case of eukaryotic cells with a total number of 10 compartments.
%
Furthermore, we experimented with limits of our tools and found that {\smttool} was able to solve the constraints up to $20$ nodes.

\input{qbf-table}
%\textbf{Universal Condition:}
\todo{SA: will improve after experimentation.}
Table~\ref{tab:qbf-graph} presents the result of the QBF tool.
%
The table represents the result of the graph connectivity for each variation of the VTS.  
%
For example, we found that the 3-connected graph satisfies the universal condition for the variation 2. 
%
Note that for this variation existential condition result was the 2-connected graph. 
%
For every other version, the results remained the same.
% 
The experimentations were done using two QBF solvers: \depqbf and \rarqbf.

%(there is a satisfying assignments to satisfy constraints of VTS) is valid VTS.   
%\textbf{Synthesis}:

We have applied~\ourtool~on six partially defined VTSs.
%
The results are presented in Fig~\ref{tab:synth-graph} for both the solvers
\depqbf and \zthree.
%
To use~\zthree, we remove \texttt{Connected} constraints, such that the queries becomes
quantifier-free.
%
% The experiments were conducted on a machine,
% with \ashu{?}MHz processor, \ashu{?}GB memory, and 900s timeout.
%
%The experiments were conducted with a 900s timeout.
%
The first four VTSs are synthetic but inspire from literature for
typical motifs in VTSs. 
The third VTS is a subgraph of the last VTS.
%
%
The fifth VTS is taken from~\cite{burri2004complete}.
%
The last VTS represent mammalian SNARE map created by studying the literature references.  
%
The fig shows timing for various synthesis queries.
%
For each synthesis query, we have two columns.
%
One column reports the timing and the other reports the minimum changes needed to obtain a valid VTS.
%
$\infty$ indicates that any number of changes with the synthesis query
search space can obtain the VTS.
%
%\ashu{@ankit: please discuss all the synthesis queries in the table.}

In the Fig~\ref{tab:synth-graph}, we report five synthesis queries.
%
The first one only adds new labelled edges to the graph.
%
We have ranked the all possible graph edits with the simple rank of
minimum updates.
% %
% Our tools were able to complete the graphs by adding five new edges
% and nine new molecules in 210s.
%
The second query adds new labels to the edge.
%  and was able to
% fix the graphs with eleven new molecule labels in 180s.
%
The third query synthesizes NNF Boolean functions only containing
$\land$ and $\lor$ gates for activity functions, while allowing
more edges to be added.
%
The result shows the basic template of 4 leaves and 3 gates.
%
% The tool was able to synthesize the Boolean functions in 470s.
%
To illustrate the versatility of our tool, the fourth query
synthesizes $3$-CNF functions (encoding not presented).
%  and was able to
% synthesis the results for all graphs in 500s.
%
Finally, we report queries that allows both addition and deletion of edges, and labels
of node and labels. 

%
%Our experiments suggest that the synthesis problems are solvable by modern 
%solvers and the synthesis technology may be useful for biological research.
%

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
