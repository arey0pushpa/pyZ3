%\externaldocument{sat-table}
%\externaldocument{smt-table}
%\externaldocument{qbf-table}
\noindent In the previous section, we have discussed in total four problems, $\fbmc$ search, $\fsmt$ search, $\fqbf$ search and synthesis problem.
%
In this section, we will present encodings for each of them.
%
Although the underlying technique for $\fbmc$ and $\fsmt$ search varies, the encoding is very similar. 
%
So, instead of presenting serially the complete encoding of both, we will start with the complete $\fsmt$ search encoding and present only the relevant part of the $\fbmc$ encoding to show a contrast.
%contrast with the $\fbmc$ encoding.

\subsection{Encoding for $\fsmt$ search problem}
\label{enc:smt}

%\subsection{Boolean satisfiability of the search problem}
\noindent We translate the search problem into a Boolean satisfiability
problem and use SMT solvers to find the satisfying VTSs.
%
We will first present the variables used to encode the
VTSs and the properties.
%
Afterward, we will present the constraints corresponding to the
properties.

\subsubsection{Variables for VTS description}
%
We assume that the size of the graph is $\nu$ and number of molecules is
$\mu$.
%
Furthermore, we also limit the maximum number of $\pi$ of edges present
between two nodes.
%
Here, we list the vector of Boolean variables and uninterpreted function symbols that encode the VTSs.
\begin{enumerate}

\item Boolean variable $n_{i,m}$ indicates if $m \in \nlabel(i)$
\item Boolean variable $e_{i,j,q}$ indicates if $q$th edge exists between $i$ and $j$.
\item Boolean variable $e_{i,j,q,m}$ indicates if $q$th edge between $i$ and $j$ contains $m$.
\item Boolean variable $p_{m,m'}$ indicates if $(m,m') \in \pairs$
\item uninterpreted Boolean functions $\nodef_m : \booleans^\mu \maps \booleans$
encoding $\nodef(m)$ map
\item uninterpreted Boolean functions $\edgef_m : \booleans^\mu \maps \booleans$
encoding $\edgef(m)$ map
\end{enumerate}
We also have auxiliary Boolean variables that will help us encode the well-fused and stability properties 
\begin{enumerate}
\item $a_{i,m}$ indicates that molecule $m$ is active at node $i$, i.e., $\nodef(m,L(i))$
  holds
\item $b_{i,j,q,m}$ indicates that molecule $m$ is active at $q$th edge $(i,M',j)$ between $i$ and $j$, i.e., $\edgef(m,M')$ holds
\item $r_{i,j,m,p}$ indicates if there is an $m$-path from
  $i$ to $j$ of length less than or equal to $p$
\end{enumerate}
For $k$-connected property, we also use the following auxiliary Boolean variables
\begin{enumerate}
\item $d_{i,j,q}$ indicates $q$th edge between $i$ and $j$ is dropped
\item $r'_{i,j}$ indicates if there is a path from $i$ to $j$ in the modified VTS
\end{enumerate}

We will describe the Boolean constraints that encode VTSs in several categories.
%
In the end, we will present in a table the constraints needed for the
model variants.
%
To avoid cumbersome notation, we will not explicitly write the ranges of the indexing
in the constraints.
%
$i$ and $j$ will range over nodes.
%
$m$ will range over molecules.
%
$q$ will range over edges between two nodes, i.e., from $1$ to $\pi$.
%

\subsubsection{Constraints on presence, activity of the molecule, and pairing matrix}
%
We need the following constraints \texttt{EdgeC},
\texttt{ActivityC} and \texttt{PairingC} to encode the basic structure of VTSs.
%
For an edge to exist it should have one molecule present. 
%
\begin{align*}
  \texttt{PresentE} = \bigwedge\limits_{i,j,q} (\bigvee_m e_{i,j,q,m} )\limplies e_{i,j,q}
\end{align*}
The edge labels are subset of the node labels of the source and target nodes.
\begin{align*}
  \texttt{LabelE} = \bigwedge\limits_{i,j,q,m} e_{i,j,q,m} \limplies (n_{i,m} \land n_{j,m} )
\end{align*}
Self edges are not allowed. 
\begin{align*}
  \texttt{SelfE} = \bigwedge\limits_{i,q} \neg e_{i,i,q}
\end{align*}
\noindent We define \texttt{EdgeC} to collect all the edge related constraints. 
%
\texttt{EdgeC} states that each edge has at least one molecule,
 edge labels are consistent with node labels and there are no self-loops.    
\begin{align*}
  \texttt{EdgeC} = \texttt{PresentE} \land \texttt{LabelE}  \land \texttt{SelfE} 
\end{align*}
\noindent If a molecule is active on an edge, it should be present on the edge.
%
\begin{align*}
  \texttt{ActiveMolE} = \bigwedge\limits_{i,j,q,m} b_{i,j,q,m} \limplies e_{i,j,q,m}\label{eq:f1}
\end{align*}
A molecule should be present to be active on a node.  
\begin{align*}
    \texttt{ActiveMolN} = \bigwedge\limits_{i,m} a_{i,m} \limplies n_{i,m}
\end{align*}
\noindent We define \texttt{ActivityC} to group all the molecule activity related constraints. 
\texttt{ActivityC} states that all active molecules are present.
\begin{align*}
  \texttt{ActivityC} = \texttt{ActiveMolE} \land \texttt{ActiveMolN} 
\end{align*}
\noindent We divide the pairing matrix into Q-SNAREs and R-SNAREs blocks and set the dependency bits of R-SNAREs to R-SNAREs in the pairing matrix to be all 0's.
%It reduces the search space.
% Condition on $p_{kk'}$. \ashu{why???} .
%\begin{align}
%  \bigwedge\limits_{(x < M/2 \, \land  \, y < M/2) \lor  (x >= M/2 \land y >= M/2)} \neg p(x,y)
%  \tag{V6}\label{eq:c3}
%\end{align}

\begin{align*}
 \texttt{PairingC} =\;& \bigwedge\limits_{(x >= 3M/4 \, \land \, y >= 3M/4)} \neg p(x,y)
\end{align*}

\subsubsection{Well-fused constraints}
Constraint \texttt{Fusion1} encodes that each edge must fuse with
its destination node.
%
Constraint \texttt{Fusion2} encodes that each edge should not
be able to potentially fuse with any node other than its destination node.
\begin{align*}
\texttt{Fusion1} =\;&
\bigwedge\limits_{i,j,q} e_{i,j,q} \limplies
\bigvee_{{m_1,m_2,m_3,m_4}} (\Land_{l=1}^4 ( b_{i,j,q,m_l} \lor a_{j,m_l} ) \land 
\Lor\limits_{l=1}^4 b_{i,j,q,m_l} \land\\
& \qquad \qquad \qquad \qquad \Lor\limits_{l=1}^4 a_{j,m_l}\land p_{\{m_1,m_2,m_3,m_4\}})
\\
\texttt{Fusion2} =\;&
\bigwedge\limits_{\mathclap{i,j,q,m_1,m_2,m_3, l \in \{1,..,3\}}} b_{i,j,q,m_1} \land ..\land b_{i,j,q,m_l} \limplies \\
& \hspace{2cm} \neg 
\bigvee_{\mathclap{j \neq j^{\prime}, m_{l+1}^{\prime},..,m_{4}^{\prime}}} ( a_{j^{\prime},m_{l+1}^{\prime}} \land .. \land a_{j^{\prime},m_4^{\prime}} \land p_{\{m_1,..,m_l,m^{\prime}_{l+1},..,m^{\prime}_4\}})
\\
\end{align*}
We define \texttt{FusionC} to group all the fusion related constraints.
% 
\texttt{FusionC} states that every edge in the graph is well-fused.
\begin{align*}
\texttt{FusionC} = \texttt{Fusion1} \land \texttt{Fusion2} 
\end{align*}
% Fusion rules consist of two different mechanisms.
% \begin{enumerate}
% \item  A \textbf{pairing mechanism} which determines compatible Q-R pairs on vesicles and compartments that can cause fusion.
% \item \textbf{regulatory mechanisms} on the edges and nodes (possibly distinct) which regulates molecules activity based on the presence/absence of other molecules on the corresponding node or edge.
% \end{enumerate}
% Boolean constraint~\eqref{eq:fuse1} and~\eqref{eq:fuse2} are used to encode well-fused
% property.

% F4: For an edge to be valid, at least one SNARE pair on the vesicle and target compartment must be active and have a non-zero entry in the pairing matrix.  

% F5: To ensure that fusion respects the graph structure by the edge under consideration, it should not be possible to fuse with any other node.


\subsubsection{Regulation on nodes and edges (Activity function)}
We are considering several models of VTS that differ in types of regulations on the molecule both on the node and on the edge.  
%constraints on the activity of molecules.
%
%We will present~\eqref{eq:ann}-~\eqref{eq:aep} that encodes
%the varying constraints.
%
The activity of the molecules is controlled by activity functions.
%
We will have encoded five variations of the Boolean functions based on the biological discussion.
%
The concrete functions encoding is presented below.
%
We will use \texttt{NodeFun}$_m$ and \texttt{EdgeFun}$_m$ for node and edge regulations respectively.
%

The following constraint encodes no conditions on activities on nodes,
i.e., all the present molecules on the nodes are active.
\begin{align*}
\texttt{FunNoN} =& \bigwedge\limits_{i,m} n_{i,m} = a_{i,m}  
\end{align*}
The following constraint encodes that activity of a molecule $m$ on the node is
defined by a Boolean function $\nodef_m$ of presence of molecules present on that node.
\begin{align*}
\texttt{FunBfN} =& \bigwedge\limits_{i,m} n_{i,m} \limplies a_{i,m} =  \nodef_m (n_{i,1},\dots,n_{i,\mu}) 
\end{align*}
The following constraint encodes no conditions on activities on edges,
i.e., all the present molecules on the edges are active.
\begin{align*}
 \texttt{FunNoE} =& \bigwedge\limits_{i,j,q,m} e_{i,j,q,m} = b_{i,j,q,m}
\end{align*}
The following constraint encodes that activity of a molecule $m$ on the edge is defined by a Boolean function $\edgef_m$ of the presence of molecules present on that edge.
\begin{align*}
 \texttt{FunBfE} =& \bigwedge\limits_{i,j,q,m} e_{i,j,q,m} \limplies b_{i,j,q,m} = \edgef_k(e_{i,j,q,1}, .., e_{i,j,q,\mu} )
\end{align*}
%
The following constraint encodes that the activity of the molecules on
edges is defined by inhibition by other molecules based on the pairing
matrix. 
\begin{align*}
\texttt{FunPairE} =&	\begin{aligned}[t]
\bigwedge\limits_{i,j,q, m}  [e_{i,j,q,m} \land \bigwedge_{m_l \neq m,l \in \{1,..,3\}} e_{i,j,q,m'} \land p_{m, m_l}] \limplies\\
	(\neg b_{i,j,q,m} \land \bigwedge_{\mathclap{m_l \neq m,l, p_{m, m_l} \in \{1,..,3\}}} \neg b_{i,j,q,m_l})\end{aligned}\\
\end{align*}
%
We denote the particular choice of node and edge function combined by \texttt{ActivityFun}.
\begin{align*}
\texttt{ActivityFun} = \texttt{NodeFun}_m \land \texttt{EdgeFun}_m
\end{align*}
\subsubsection{Constraints for stability condition}
%
We use $m$-reachability to encode the stability condition in VTSs.
%
The following constraint recursively encodes that node $j$ is $m$-reachable from node $i$ in less than $p$ steps
if either there is a direct edge between $i$ and $j$ with $m$ present on the edge or there is a edge between $i^{\prime \prime}$ and
$(i \neq i^{\prime \prime})$ with $m$ present, and j is $m$-reachable from $i'$ in less than $p-1$ steps.
%
\begin{align*}
  \texttt{Paths}(r) &= \bigwedge\limits_{i,j,m,p} r_{i,j,m,p} \limplies (\bigvee_{q} \, e_{i,j,q,m} \lor \bigvee_{i\neq i^{\prime}} ( \, \bigvee_{q} e_{i,i^{\prime},q,m}) \land r_{i^{\prime},j,m,p-1} )
\end{align*}
Now we can encode stability using the reachability variables.
and say if there is an $m$-edge between $i$ and $j$, there is
$m$-reachable path from $j$ to $i$.
\begin{align*}
 \texttt{Loop}(r) &= \bigwedge\limits_{i,j,m} (\bigvee_{q} e_{i,j,q,m}) \limplies r_{j,i,m,\nu}
\end{align*}
We define \texttt{StabilityC} to group all the stability related constraints.
% 
\texttt{StabilityC} states that every molecule is moving in a cycle.
\begin{align*}
\texttt{StabilityC} = \texttt{Paths}(r) \land \texttt{Loop}(r) 
\end{align*}
% Boolean variable
% F3 and F2 are used to model these constraints. 

% % \textbf {Reachability definition and stability condition.}
% We have encoded stable condition by using reachability definition. \newline

% F3: Stability condition. For every leaving molecule, the source node is reachable from the target node with that molecule present, in maximum p steps. 


% F2: Reachability definition. Node j is reachable from node i with kth molecule present in maximum p steps if either there is a direct edge between i-j with that molecule present or there is a direct edge between $i^{\prime \prime}$ $(i \neq i^{\prime \prime})$ and j with kth molecule present on that edge and $i^{\prime \prime}$ are reachable from i in p steps. 


\subsubsection{$k$-connectivity constraints}
To check whether $k$-connected is a necessary condition, we remove (drop) $k-1$ edges from the graph and if it
disconnects the graph, and we get an assignment. We have a graph that is not  $k$-connected.
%
Constraints \texttt{Fail}(d,k), \texttt{FReach}(d,r') and \texttt{Connected}(r')
encode the relevant constraints for reachability
in the modified VTS. 
%
The following constraints encode that only
existing edges can be dropped and exactly $k-1$ edges are dropped.
\begin{align*}
\texttt{Fail}(d,k) = & 
\bigwedge\limits_{i,j,q} d_{i,j,q} \limplies e_{i,j,q}  \land 
\sum_{i,j,q} d_{i,j,q} = k-1\\
\end{align*}
We need to define reachability in the modified VTS, therefore we use
a new variable $r'_{i,j}$ to encode reachability from $i$ to $j$.
In the following constraint, we encode $r'_{i,j}$ is true if there is an
edge $(i,\_,j)$ and it is not dropped, or there is a node
$i^{\prime}$ such that, there is an edge $(i,\_,i^{\prime})$ which is
not dropped and $r'_{i',j}$ is true.
\begin{align*}
\texttt{FReach}(d,r') = &  \bigwedge\limits_{i,j}  [\bigvee_{q} (e_{i,j,q} \land  \neg d_{i,j,q}) \lor  (\bigvee_{i' \neq i}  r^{\prime}_{i',j} \land  \bigvee_{q} (e_{i,i',q} \land \neg d_{i,i',q}) ] \limplies r^{\prime}_{i,j}  
\end{align*}
Since we search for disconnected modified VTS,
the following constraint encodes that there are 
unreachable pair of nodes in the underlying undirected graph.
% nodes such that
% there is no path between them .
\begin{align*}
   \texttt{Connected}(r')  = & \bigvee\limits_{i,j} \neg (r^{\prime}_{i,j} \lor r^{\prime}_{j,i})
\end{align*}
We define $\texttt{Connected}(k)$ that says graph is not k-connected.
\begin{align*}
\texttt{Connected}(k) = \texttt{Fail}(d,k) \land \texttt{FReach}(d,r') \land \texttt{Connected}(r') 
% \\
% \texttt{Disconnected}(k) = & \exists d.\;
%         (\texttt{Drop}(d,k) \land \exists r'.\;\texttt{ReachAbove}(d,r')
%                               \land \lnot \texttt{Connected}(r'))
\end{align*}
% We can go down or up using -C \_ option.  \newline 


\subsection{Encoding for $\fbmc$ search problem}
\label{enc:bmc}
\noindent Our first attempt was to encode the existential condition as a $\fbmc$ search problem~\cite{shukla2017discovering}.
%
%In this section we will present the $\fbmc$ encoding of the same.
%The basic idea is to search the solution only upto a certain depth $w$. 
%
%\begin{align*}
%\npath(m, i, j, w) = \bigvee\limits_{l = 1}^{w-1} (\texttt{Length} (m-path_{ij}) == l)
%\end{align*}
%
%
%\begin{align*}
%\bigwedge\limits_{i,j,m} (\bigvee_{q} (\texttt{bvEdge}[i][j][q] \unrhd m) == 1) \limplies \npath(m, j, i, w)
%\end{align*}
%Although the techniques used for $\fbmc$ and $\fsmt$ is very different because we are 
%In $\fbmc$ we only partially unroll the program to check for the solutions within that subset. 
%in the case of $\fbmc$, the encoding is not considerably different.
% 
The main differences between $\fsmt$ and $\fbmc$ are the representation of variables and the encoding of 
%I n comparison to $\fsmt$, the $\fbmc$ search encodes 
reachability (both for the stability and connectivity).  
%]
Here, we will only present the stability encoding.
%the rest of the encodings are similar to the one presented in the previous section, Section~\ref{enc:smt}.

In the $\fbmc$ encoding, the label of the edges and nodes are represented by variables of type, \textit{array of bit vector} of size $M$. 
%
For example, the variable \texttt{bvEdge}$[i][j][q]$, represent the label of the $q$th edge between node $i$ and $j$.

% with each bit corresponding to the presence or absence of the molecule. 
%
%In the $\fbmc$ encoding, variables are represented as an array of bit vectors of size $M$. 
%
%We initialize the system with a fixed number of node size (N) and distinct molecular types (M). 
%%
%We use a two-dimensional array variable \textit{Graph}[N][N] to represent the transport graph. The graph variable is set to x, Graph[i][j] = x, if there are exactly x edges between node i and j. 
%\begin{align*}
%graph [i] [j] = x.
%\end{align*}
%
%For example, every edge is represented as a bit vector of size $M$ with each bit corresponding to the presence or absence of the molecule. 
%
%Bit vector \texttt{bvEdge}$[i][j][q]$ represent the $q$th edge between node $i$ and $j$.
%
%The index of the bit vector implicitly determines the corresponding molecule we are referring to in the edge.
% 
%The molecule set is divided into Q and R-SNAREs. 
%
%For clarity, we consider the first part of the bit vector as Q-SNAREs and rest as R-SNAREs.
%
%An edge in the system with $M$ = 4 molecules is interpreted as a label [$M_{1}, M_{2}, M_{3}, M_{4}$]. 
%
%Where $M_{1}, M_{2}, M_{3}$ are Q-SNAREs while $M_{4}$ is a R-SNARE.
%
%Also, each $M_i$ can be either 0 or 1, representing the presence or absence of the $i^{th}$ molecule.
%
%For example, the variable \texttt{bvEdge}[1][2][1] = 1001, represents the first edge between node 1 and node 2 with molecule $M_{1}$ (Q-SNARE) and $M_{4}$ (R-SNARE) present. 
%
%Similarly, a node in the graph is also labelled as a bit vector of length $M$.   
%
%We leave the graph completely arbitrary and add the constraint to enforce that the graph is k-connected. 
%
%
The value of the bit vector variable describes the presence of the corresponding molecules at that particular location. 
%
For clarity, we consider the first part of the bit vector as Q-SNAREs and rest as R-SNAREs.
%
For an edge in the system with $M$ = 4 molecules, the variable \texttt{bvEdge}[2][1][0] = $1001$, means the molecule  $M_{1}$ (Q-SNARE) and $M_{4}$ (R-SNARE) are present on the first edge between node 2 and node 1.

To specify the stability condition, we use nondeterminism to encode the existence of a path. 
%
The nondeterminism can be viewed as a guess of the correct path if it exists. 
%
We then use this path as a witness to ensures that stability is maintained for each outgoing molecule $m$ from an edge $E$.
%
A basic encoding of it using enumeration is shown.
%Nondeterminism can be viewed as an oracle that guesses a correct path for a specific $m$ if it exists. 
%
%We then use this path as a witness to ensures that stability is maintained for each outgoing molecule $m$ on every edge $E$.
%
%
%Only partial enumeration up to an unwinding depth of $w$ is performed.
Note that the enumeration is performed only up to an unwinding depth of $w$.
%
%The encoding presented below uses a nondeterministic path and perform enumeration to find it. 
\subsubsection{Constraints for stability condition}
%
A path between node $i$ and $j$ in the graph is an $m$-$path_{ij}$ if molecule $m$ is present on edges along that path.
%
%We use {\npath} to represent the required path to encode the stability condition in VTS.
%
%A naive implementation is shown in~\ref{eq:reachbmc1} where 
We use {\npath}$(m, i, j, w)$ to represent the presence of a $m$-$path_{ij}$ of maximum $w$ length.
%there is a edge between $i^{\prime \prime}$ and01
%$(i \neq i^{\prime \prime})$ with $m$ present, and j is $m$-reachable from $i'$ in less than $p-1$ steps.
%
% \begin{align}
%   NOracle (m, i, j, w) = \exists \, path[h1, ..., hn]: \\ 2 \leq |path| \leq  w + 2  \, \land h1 = i \, \land  hn = j \, \land \\ 
%   \bigvee\limits_{k = 1}^{|path|- 1} \bigvee\limits_{q}  E[hk] [hk+1][q][m] 
%   \tag{S1}\label{eq:reach1}
% \end{align}
%The NOracle can be thought of as a disjunction of $m$-path of increment length. 
%
$\npath(m, i, j, w)$ performs enumeration of every $m$-$path_{ij}$ of at most $w$ length. 
%
Starting with exploring $m$-${paths}_{ij}$ of length 1; a direct edge between $i$ and $j$ with molecule $m$ present, until every $m$-${paths}_{ij}$ of length $w-1$ is explored.
%by performing series of node hops till final node destination j is reached.
%Starting with $m$-${paths}_i^j$ of length 1 which is a direct edge between $i$ and $j$ with molecule $m$ present on the edge or performing series of node hops till final node destination j is reached.
%
%|m-path| = 1 \lor  |m-path| = 2 \lor ...  |m-path| = w.     \\
%\bigvee\limits_{l = 1}^{|path| - 1} |m-path| = l
%
\begin{align*}
\npath(m, i, j, w) = \bigvee\limits_{l = 1}^{w-1} (\texttt{Length} (m \mhyphen path_{ij})~\texttt{=}\texttt{=}~l)
\end{align*}

We encode stability using \npath. For every edge with $m^{th}$ molecule present between node $i$ and $j$ then there exists a $m$-$path_{ji}$ of maximum $w$ length.
%
The expression (\texttt{bv} $\unrhd$ $m$) extracts the $m^{th}$ bit of the bitvector \texttt{bv}. 

\begin{align*}
	\bigwedge\limits_{i,j,m} (\bigvee_{q} (\texttt{bvEdge}[i][j][q] \unrhd m)~\texttt{=}\texttt{=}~1) \limplies \npath(m, j, i, w)
\end{align*}

%A variant of the definition may be sensitive to the $m$-connectedness, but
%we are not considering the variation.

\subsubsection{The key difference in the reachability encoding}
The key improvement of the $\fsmt$ search encoding over the $\fbmc$ is the
encoding of reachability.
% which was done using an enumeration of paths.
%
In the $\fbmc$ encoding, reachability is encoded by enumerating all the possible paths using nondeterminism.
%
This encoding is non-optimal in the sense that in the worst case an exponential number of paths needs to be explored.
%
Whereas in the $\fsmt$ encoding, reachability is encoded in two different
ways in constraints $\texttt{Paths}(r)$ and $\texttt{FReach}(d,r')$.
%
The reachability is recursively defined in~$\texttt{FReach}(d,r')$ and has
trivial solutions by making all $r'$s true.
%
However, the trivial solutions are disallowed by constraint~$\texttt{Connected}(r')$ and we find
only the solutions that capture the evidence of non-reachability.
%
On the other hand, we have added the length of paths in our reachability encoding in constraint~$\texttt{Paths}(r)$, which needs relatively more auxiliary variables.
%
This is because constraint~$\texttt{Loop}(r)$ has only positive
occurrences of the reachability variables and if we had defined
$r$s in~$\texttt{Paths}(r)$ without paths,
the circular dependencies in the recursive definitions of $r$s
may have resulted in spurious satisfying assignments that
do not encode reachability.
%
By adding the path length, we break the circular dependencies, the
constraint remains polynomial in size, and satisfying assignments only
correspond to correct reachability.

\input{variation-table}

\subsubsection{$\fbmc$ and $\fsmt$ search problems for different variants}
%\ankit{Bring model variant table here}

We have encoded the following variants of VTSs.
%
The variants are due to different combinations of constraints on the
activity of molecules on the nodes and edges.
%
\begin{enumerate}
\item Every present molecule is considered to be active.
\item Activity of molecules on the nodes is based on Boolean function of the presence of other molecules. 
\item Activity of molecules on the edges is based on Boolean function of the presence of other molecules
\item Activity of molecules both on the edges and nodes is based on Boolean function of the presence of other molecules.
\item Activity of molecules on the edges is driven by pairing inhibition.
\item Activity of molecules on the nodes is based on Boolean function of the presence of other molecules and on edge by pairing inhibition.
\end{enumerate}
%
% For the version A, every present molecule is in active state.
%

In the Table~\ref{tab:var-grph}, we present the constraints involved in each version.
%
The column two of the table shows that the constraints $\texttt{EdgeC}$, $\texttt{ActivityC}$, $\texttt{PairingC}$, $\texttt{FusionC}$, $\texttt{StabilityC}$ and $\texttt{Connected}(k)$ are present for every variant.
%
The last two columns of the table lists the activity constraints that are different among the variants.
%
%
%One of the restriction is where the activity of the present molecule is dependent on the presence of the other molecules.
%
%For example in version B, D, F activity of the molecules on the node is a boolean function of the presence of other molecules on that node; Anb.
%
%Similarly for the case of the edge in version C and D; Aeb.
%
%In the case of versions F the activity of the molecules on the edges
%is described by pairing matrix; Aep.

%if all the pairs of the present molecule are present on the same edge than all of them inhibit each other resulting in making all the molecules inactive, we term this process ``pairing inhibition".
%
The constraints for the variants can be given to a SAT or a SMT solver to find
VTSs that belong to the variants.
\subsection{Encoding for $\fqbf$ search problem}\label{enc:univ-cond}
%
\input{satqbf-table}
\noindent The specification for universal condition~\ref{sec:property} requires quantifier alternation. 
%
Most SAT solvers can not efficiently handle the quantifier in the formulas. 
% 
Although, it is possible to encode the universal condition as a SAT or SMT problem.
%
There is always a danger of a blow-up in the formula size, making it harder for the SAT solver to handle. 
%Which may blow up the formula size for the solver to solve.
% 
As an experiment, we have implemented a direct SMT version (encoding not presented) of the universal problem extending the current $\fsmt$ search encodings.
%
The basic idea is to conjunct the formula for each combination value of the quantified variable. 
%
The Table~\ref{tab:satqbf-graph}, shows the search results of this encoding for the universal condition with 4 nodes and 3-connected graphs. 
%
The connectivity constraint and connectedness constraints are tagged with subscript $U$, $\texttt{StabilityC}_{U}$, $\texttt{Connected}(k)_{U}$,  to distinguish from earlier presented encodings of existential condition.
%
The SMT extended version was not able to scale it to the desired results and either timed-out (T/O) or ran out of memory (M/O).
%
This can be due to the fact that directly translating a quantified formula into a quantifier-free by introducing a vector of variables for each boolean possibility can lead to exponential increase in the formula size.
%
%
\subsubsection{$\fqbf$ search encoding of the universal condition}
We will describe several constraints that encode universal condition based on QBF formulation in this section.
%
To avoid cumbersome notation, we will not explicitly write the ranges
of the indexing in the constraints.
%
$i$ and $j$ will range over nodes, i.e., from $1$ to $\nu$.
%
$m$ will range over molecules, i.e., from $1$ to $\mu$.
%
$q$ will range over edges between two nodes, i.e., from $1$ to $\pi$.
%

We rewrite \texttt{PairingC} constraint using quantifiers.
%
The \texttt{QPairingC} states that all molecules are divided into two types
using $qr_m$ bit, which encodes if $m$ belongs to one type or another,
and any fusing set of molecules must have three molecules involved
%
We encode this constraint as a QBF.
\begin{align*}
 \texttt{QPairingC} =\;&
\exists qr. \Land\limits_{\mathrlap{m_1,m_2,m_3,m_4}\;\;}
(p_{\{m_1,m_2,m_3,m_4\}} \limplies qr_{m_1} + qr_{m_2} + qr_{m_3} + qr_{m_4} = 3)
\end{align*}
Using constraints for VTS from Section~\ref{enc:smt}, we encode the basic consistency of VTSs. 
%
%Recall that the molecule set is divided into 3:1 Q and R pairs (or partition).
\begin{align*}
%\texttt{EdgeC} =\;&\hspace{-1ex}\bigwedge\limits_{i,j,q} (\bigvee_m e_{i,j,q,m} )\limplies e_{i,j,q}
%\land
%\bigwedge\limits_{i,q} \neg e_{i,i,q}
%\land
%% \tag{\texttt{NodeC}}\label{eq:f0}\\
%\bigwedge\limits_{\mathclap{i,j,q,m}} e_{i,j,q,m} \limplies (n_{i,m} \land n_{j,m} )
%\\
%\texttt{ActivityC} =\;&
%\bigwedge\limits_{\mathclap{i,j,q,m}} b_{i,j,q,m} \limplies e_{i,j,q,m} \quad\land\quad
%\bigwedge\limits_{i,m} a_{i,m} \limplies n_{i,m}
%% \tag{V2}\label{eq:f1}\\
%\\
%\texttt{PairingC} =\;&
%\exists qr. \Land\limits_{\mathrlap{m_1,m_2,m_3,m_4}\;\;}
%(p_{\{m_1,m_2,m_3,m_4\}} \limplies qr_{m_1} + qr_{m_2} + qr_{m_3} + qr_{m_4} = 3) 
%% \land\\ 
%%   & \quad\quad\quad ( m_1 = m_2 = m_3 = m_4  \limplies \lnot p_{m_1,m_2,m_3,m_4} )
%% \bigwedge\limits_{m} 
%% (\Lor\limits_{m'} p_{mm'} \limplies \Land_{m'} \lnot p_{m'm} ) \land
%% (\Lor\limits_{m'} p_{m'm} \limplies \Land_{m'} \lnot p_{mm'} )
%\\
%\texttt{Fusion1} =\;&
%\bigwedge\limits_{i,j,q} e_{i,j,q} \limplies
%\bigvee_{{m_1,m_2,m_3,m_4}} (\Land_{l=1}^4 ( b_{i,j,q,m_l} \lor a_{j,m_l} ) \land 
%\Lor\limits_{l=1}^4 b_{i,j,q,m_l} \land\\
%& \qquad \qquad \qquad \qquad \Lor\limits_{l=1}^4 a_{j,m_l}\land p_{\{m_1,m_2,m_3,m_4\}})
%\\
%\texttt{Fusion2} =\;&
%\bigwedge\limits_{\mathclap{i,j,q,m_1,m_2,m_3, l \in \{1,..,3\}}} b_{i,j,q,m_1} \land ..\land b_{i,j,q,m_l} \limplies \\
%& \hspace{2cm} \neg 
%\bigvee_{\mathclap{j \neq j^{\prime}, m_{l+1}^{\prime},..,m_{4}^{\prime}}} ( a_{j^{\prime},m_{l+1}^{\prime}} \land .. \land a_{j^{\prime},m_4^{\prime}} \land p_{\{m_1,..,m_l,m^{\prime}_{l+1},..,m^{\prime}_4\}})
\texttt{Consistancy} =\;& \texttt{EdgeC} \land
\texttt{ActivityC} \land \texttt{QPairingC} \land
\texttt{Fusion} 
\end{align*}
%\texttt{EdgeC} states that each edge has at least one molecule,
%there are no self loops, and edge labels are consistent with node labels.   
%\texttt{ActivityC} states that active molecule are present.
%\texttt{PairingC} states that all molecules are divided into two types
%using $qr_m$ bit, which encodes if $m$ belongs to one type or another,
%and any fusing set of molecules must have three molecules involved
%from one type and one molecule from the other.
%\texttt{Fusion1}, and \texttt{Fusion2} states the well-fused condition.
%\texttt{Consistancy} is the conjunction of all of the above.

\paragraph{Activity functions}
%
Activity functions are encoded as presented in the Section~\ref{enc:smt}.
%We also need to encode that the activity of the molecules are
%controlled by activity functions.
%
%The input VTS may include concrete activity functions for some molecules,
%and for the others the functions may be unknown and to be synthesized. 
%
%The concrete functions can be given to us in many different ways,
%for example as a lookup table, or a concise Boolean formula.
%
%In the following section, we will assume the appropriate encoding is
%used for the concrete functions and represent them by \texttt{NodeFun}$_m$
%and \texttt{EdgeFun}$_m$ for node and edge regulations respectively.
%
%We will use $\nodef_m$ and $\edgef_m$ to represent functions that
%are unknown in a VTS.
%
% \begin{align}
% \bigwedge\limits_{i,m} n_{i,m} \limplies a_{i,m} =  \nodef_m (n_{i,1},\dots,n_{i,\mu}) 
% \tag{\texttt{ActiveN}}\label{eq:anb}\\
%    \bigwedge\limits_{i,j,q,m} e_{i,j,q,m} \limplies b_{i,j,q,m} = \edgef_m(e_{i,j,q,1}, .., e_{i,j,q,\mu} )
%   \tag{\texttt{ActiveE}}\label{eq:aeb}
% \end{align}
%
%Later we will be synthesizing the unknown activity functions and 
%replace $\nodef_m$ and $\edgef_m$ with parameterized constraints that
%encode a space of candidate functions.
%\subsubsection{VTS properties}
%For the synthesis of incomplete systems,
%we need properties against which we synthesize the missing parts.
%
Next, we will discuss stability and $k$-connectedness.
%

\paragraph{Stability property}
%
%We use Boolean variable $r_{i,j,m,p}$ to indicate if there is an
%$m$-path from $i$ to $j$ of length less than or equal to $p$.
%
%We use $m$-reachability to encode the stability condition in VTSs.
%%
%The following constraint recursively encodes that node $j$ is
%$m$-reachable from node $i$ in less than $p$ steps.
%%
We encode stability condition using the reachability variables like presented in Section~\ref{enc:smt}. 
%
Recall the definition of $\texttt{Paths}(r)$ and $\texttt{Loop}(r)$ constraint from Section~\ref{enc:smt}.
%  
\begin{align*}
\texttt{Paths}(r) &= \bigwedge\limits_{\mathclap{i,j,m,p}} r_{i,j,m,p} \limplies (\bigvee_{q} \, e_{i,j,q,m} \lor \bigvee_{i\neq i^{\prime}} ( \, \bigvee_{q} e_{i,i^{\prime},q,m}) \land r_{i^{\prime},j,m,p-1} )
\\
\texttt{Loop}(r) &= \bigwedge\limits_{i,j,m} (\bigvee_{q} e_{i,j,q,m}) \limplies r_{j,i,m,\nu}
\end{align*}
We encode stability, \texttt{QStability} using quantifiers as existence of reachability bits such that constraints $\texttt{Paths}(r)$ and $\texttt{Loop}(r)$ are satisfied.
\begin{align*}
\texttt{QStability} &= \exists r. \; \texttt{Paths}(r) \land \texttt{Loop}(r)
\end{align*}
\paragraph{$k$-connected property}
%
The $k$-connectedness expresses robustness against failure of few edges.
%
%Let us use $d_{i,j,q}$ to indicate $q$th edge between $i$ and $j$ is failed
%and $r'_{i,j}$ to indicate if there is a path from $i$ to $j$ in
%the modified VTS.
%
% To check whether $k$-connected is a
% necessary condition, we remove (drop) $k-1$ edges from the graph and
% if it disconnects the graph, and we get an assignment.
% %
% We have a graph that is not $k$-connected.
%
Recall the definition of $\texttt{Fail}(d,k)$, $\texttt{FReach}(d,r')$ and $\texttt{Connected}(r')$ constraint from Section~\ref{enc:smt}.
%In the following,  encodes that only
%existing edges can be failed and exactly $k-1$ edges are failed.
%%
% defines reachability in the modified VTS.
%%
%We use a new variable $r'_{i,j,p}$ to encode reachability from
%$i$ to $j$ in at most $p$ steps.
%%
%$\texttt{Connected}(r')$ says that all nodes are reachable from any
%other node.
\begin{align*}
\texttt{Fail}(d,k) = & 
\bigwedge\limits_{i,j,q} d_{i,j,q} \limplies e_{i,j,q}  \land 
\sum_{i,j,q} d_{i,j,q} = k-1\\
% \texttt{ReachAbove}(d,r') = &
% \bigwedge\limits_{i,j}  [\bigvee_{q} (e_{i,j,q} \land  \neg d_{i,j,q}) \lor  (\bigvee_{i' \neq i}  r^{\prime}_{i',j} \land  \bigvee_{q} (e_{i,i',q} \land \neg d_{i,i',q}) ] \limplies r^{\prime}_{i,j}\\
\texttt{FReach}(d,r') = &\hspace{-1ex}
\bigwedge\limits_{i,j,p}  \hspace{-1ex}r^{\prime}_{i,j,p} \hspace{-1ex}\limplies\hspace{-1ex} [\bigvee_{q} (e_{i,j,q} \land  \neg d_{i,j,q}) \hspace{-1pt}\lor \hspace{-2pt} (\bigvee_{\mathclap{i' \neq i}}  r^{\prime}_{i',j,p-1} \land  \bigvee_{q} (e_{i,i',q} \land \neg d_{i,i',q}) ]\\
\texttt{Connected}(r') = & \Land\limits_{i,j} (r^{\prime}_{i,j,\nu} \lor r^{\prime}_{j,i,\nu})
\end{align*}
%We will be synthesizing $k$-connected graphs.
%
We define $\texttt{QConnected}(k)$ that says for all possible valid failures
the graph remains reachable. 
\begin{align*}
\texttt{QConnected}(k) = & \forall d.\;
(\texttt{Fail}(d,k) \limplies \exists r'.\;\texttt{FReach}(d,r')
\land \texttt{Connected}(r'))
% \\
% \texttt{Disconnected}(k) = & \exists d.\;
%         (\texttt{Drop}(d,k) \land \exists r'.\;\texttt{ReachAbove}(d,r')
%                               \land \lnot \texttt{Connected}(r'))
\end{align*}
Since $d$ variables in $\texttt{QConnected}(k)$ are universally
quantified, $\texttt{QConnected}(k)$ introduces quantifier alternations.
%
%Therefore, synthesis against this property will require QBF reasoning.
%%
%We may make the formula quantifier free  by considering all possible failures
%separately and introducing a vector of reachability variables for each
%failure.
%%
%However, this will blow up the size of the formula and may not be
%solvable by a SAT solver.
%
%\begin{align*}
%  & \forall G \, \texttt{Connectivity(k)} \limplies  \exists
%                        f,p: \texttt{Stability} \, \land \, \texttt{Consistancy}  
%  \tag{U}\label{eq:univcond}
%\end{align*}
%
\subsection{Encoding for the synthesis problem}
\label{enc:synth}
\noindent In this section, we will present our synthesis method for
the synthesis problems.
%
%We assume that certain properties of the partial input VTS always hold, for example, the activity of the molecules and well-fused constraints. 
%
%Whereas properties like stability and connectivity discussed in the previous sections may not.
%
Here, we use these two properties stability and connectivity against which we perform our synthesis. 
%
The encoding can be easily extended to accommodate other interesting properties. 

\subsubsection{Encoding Incomplete VTS}

In our synthesis method, we take a VTS $G =
(\nodes,\mols,\edges,\nlabel,\pairs,\edgef,\nodef)$ as input.
%
We allow activity functions not to be specified.
%
We will re-use the $\fqbf$ encodings for the input VTS as described in the Section~\ref{enc:univ-cond}.
%
We construct the following constraints to encode the available information
about $G$.
%
We encode both the present and the absent components in $G$.
%
Later, the constraints will help us encode the synthesis problems.
%
\begin{align*}
\texttt{PresentE} &= \land \{e_{i,j,q,m}|(i,M_1,j),...,(i,M_{q'},j) \in \edges \land q \leq q' \land m \in M_q \}\\
\texttt{PresentN} &= \land \{n_{i,m}| m \in \nlabel(i) \land i \in \nodes \}\\
\texttt{PresentP} &= \land \{p_{\{m_1,m_2,m_3,m_4\}}| \{m_1,m_2,m_3,m_4\} \in \pairs \} \\
\texttt{KnownActiveN} &= \land \{ a_{i,m} = \texttt{NodeFun}_m (n_{i,1},\dots,n_{i,\mu}) | \nodef_m \text{ is defined.} \} \\
\texttt{KnownActiveE} &= \land \{ b_{i,j,q,m} = \texttt{EdgeFun}_m(e_{i,j,q,1}, .., e_{i,j,q,\mu})
| \edgef_m \text{ is defined.} \} \\
\texttt{PresentCons} & = \texttt{PresentE} \land \texttt{PresentN} \land 
\texttt{PresentP} \land \texttt{KnownActiveE} \land \\
&  \texttt{KnownActiveN}
\end{align*}
We also collect the variables that are not set to true in $\texttt{PresentCons}$.
\begin{align*}
\texttt{AbsentELabel} &=
\{e_{i,j,q,m}|(i,M_1,j),...,(i,M_{q'},j) \in \edges \land 
0 < q \leq q' \land m \not\in M_{q} \}\\
\texttt{AbsentE} &= \{e_{i,j,q}|(i,M_1,j),...,(i,M_{q'},j) \in \edges \land 
q' < q \leq \pi \}\\
\texttt{AbsentNLabel} &= \{n_{i,m}| m \not\in \nlabel(i) \land i \in \nodes \}\\
\texttt{AbsentP} &= \{p_{\{m_1,m_2,m_3,m_4\}}| {\{m_1,m_2,m_3,m_4\}} \not\in \pairs \} \\
\texttt{UnknownActive} &=  \Land \{ a_{i,m} = \nodef_m (n_{i,1},\dots,n_{i,\mu}) | \nodef_m \text{ is undefined.} \} \union \\
&\quad\quad\quad  \{ b_{i,j,q,m} = \edgef_m(e_{i,j,q,1}, .., e_{i,j,q,\mu})
| \edgef_m \text{ is undefined.} \}
\end{align*}
We have defined $\texttt{AbsentELabel}$, $\texttt{AbsentE}$, $\texttt{AbsentN}$, and
$\texttt{AbsentP}$
as sets.
%
They will be converted into formulas depending
on the different usage in the synthesis problems. 
% Since not all the activity functions are defined some of the functions
% appearing in $\texttt{ActiveE}$ and $\texttt{ActiveN}$ are
% uninterpreted function symbols.
%
\subsubsection{Encoding synthesis property}
%
We will do synthesis against the following property that says the VTS
is stable and $k$-connected.
%
Where $k$ is the minimum connectivity solution of the corresponding variant in the existential condition.
%
%Where $k$ is the connectivity of the solution of the existential condition of the corresponding variant.
% The property is designed to balance the search space such that the synthesis procedure does not
% succeed with simply adding too many edges. 
%
\begin{align*}
\texttt{Property} =  \texttt{QStability} \land \texttt{QConnected}(k) 
%\land \texttt{DisConnected}(4)
\end{align*}
The property was proposed in~\cite{shukla2017discovering}.
%
However, the biological relevance of the property is debatable and open for change.
%
Our tool is easily modifiable to support any other property that may be deemed interesting by the biologists.

\subsubsection{Encoding synthesis constraints}

Now we will consider the encodings for the
listed synthesis problems.
%
The presented variations represent the encodings
supported by our tool.
%
Additionally, the combinations of the variation are also possible and
our tool easily supports them.
%
For simplicity of the presentation, we assume that if we are
synthesizing an aspect of VTS, then all other aspects are fully given.
%
Therefore, we will describe two kinds of constraints for synthesis
problems.
%
One will encode the variable part in the synthesis problem and
the other encodes the fixed parts.
%
Subsequently, the two constraints will be put together with 
$\texttt{Consistancy}$ and 
$\texttt{Property}$ to construct the constraints for synthesis.

\subsubsection{Fixing VTS by adding edges}
%
Now we will consider the case when we add new edges to VTS to satisfy the properties.
%
In the following, the pseudo-Boolean formula $\texttt{AddE}$ encodes
that at most $slimit$ new undeclared edges may be added in the VTS.
%
\texttt{FixedForEdge} encodes the parts of the VTS that are not allowed to change.
\begin{align*}
&\texttt{AddE}(slimit) = \sum~\texttt{AbsentE} \leq slimit\\
&\texttt{FixedForEdge} = \texttt{PresentCons} \land \texttt{UnknownActive} \land\\
& \quad\quad\quad\quad \lnot \Lor \texttt{AbsentELabel} \;\union\;
\texttt{AbsentNLabel} \;\union\;
\texttt{AbsentP}
\end{align*}
We put together the constraints and obtain the following formula.
\begin{align*}
& \texttt{SynthE}(slimit) =
\texttt{Consistancy}\land \texttt{Property} \land
\texttt{FixedForEdge} \land
\texttt{AddE}(slimit)
% \tag{SynthE}\label{eq:addedge1}
\end{align*}
Similar to what we have seen $\texttt{Consistancy}$ encodes the basic constraints about VTS,
$\texttt{Property}$\; encodes the goal, and
the rest two are defined just above.
%
A satisfying model of $\texttt{SynthE}$ will make 
some of the edges in $\texttt{AbsentE}$ true such that~$\texttt{Property}$ is satisfied.
%
We limit the addition of the edges since we look for a fix that requires a minimum number
of changes in the given VTS.
%
We start with $slimit = 1$ and grow one by one until $\texttt{SynthE}(slimit)$
becomes satisfiable.

In the later synthesis problems, we will construct a similar QBF
formula with same first two parts and the last two are due the
requirements of the synthesis problem.
%
\subsubsection{Fixing VTS by adding molecules to the labels}
The system may also be fixed only by modifying labels on the edges or the nodes instead
of adding edges.
%
Here let us consider only adding molecules to the labels of edges.
%
In the following, the formula encodes that only $slimit$ edge labels may be added.
%
\begin{align*}
&\texttt{AddLabelEdge}(slimit) = 
\sum~\texttt{UnknwonEdgeLabel}  \leq slimit\\
& \texttt{FixedForLabel} = \texttt{PresentCons} \land \texttt{UnknownActive} \land\\
& \quad \quad \lnot \Lor \texttt{AbsentE} \;\union\;
\texttt{AbsentNLabel} \;\union\;
\texttt{AbsentP}\\
&\texttt{SynthLabel}(slimit) = \\
& \quad\quad
(  \texttt{Consistancy}\land \texttt{Property} \land
\texttt{FixedForLabel} \land \texttt{AddLabelEdge}(slimit) )
\end{align*} 
%
Similar to the previous encoding, we solve the
satisfiability of the above formula to obtain additional molecules
that may be added to the edge labels to satisfy the properties.
%
\subsubsection{Fixing VTS by learning activity functions}
Now we consider a scenario where some of the activity functions for
some of the molecules are missing.
%
The activity functions are $\mu$-input Boolean functions.
%
First, we choose a class of formulas for the candidate functions.
%
We encode the candidates in a formula with parameters.
%
By assigning different values for the parameters, a solver may select
different candidates for the activity functions.
%
We will illustrate only one class of formulas.
%
However, we support other classes of formulas, for example, $k$-CNF.

In the following, the formula \texttt{NNFTemplate} encodes a set of
negation normal form functions that take $y_1,..,y_\mu$ as input and
contain $\lambda$ literals.
%
We use $\texttt{Gate}$ to encode a gate that takes a parameter integer
$x$ to encode various gates.
%
We use $\texttt{Leaf} $ to encode the literal at some position.
%
Both are stitched to define \texttt{NNFTemplate}.
%
To encode the set of NNF formulas with $\lambda$ literals, it has
finite-range integer variables
$z_1,..,z_{2\lambda}$ as parameters.
% \paragraph{Encoding low depth cnf circuits}
% \paragraph{Encoding boolean gates}
%
\begin{align*}
&\texttt{Gate}( x, w_1, w_2 ) = ( x  = 1 \limplies w_1  \land w_2 ) \land  
( x = 2  \limplies w_1  \lor w_2 ) \\
&\texttt{Leaf}( x, [y_1,..,y_\mu] ) =
\Land\limits_{l=1}^{\mu} ( x = 2l-1  \limplies y_{l}) \land ( x = 2l  \limplies \lnot y_{l})\\
&\texttt{NNFTemplate}([z_1,..,z_{2\lambda}],[y_1,..,y_\mu] ) = \\
&\exists w_1,..,w_{2\lambda}.\;w_1 \land \Land_{l=1}^{\lambda} w_{\lambda+l} = \texttt{Leaf}( z_{\lambda+l}, [y_1,..,y_\mu] ) \land
w_{l} = \texttt{Gate}( z_l, w_{2l},w_{2l+1})
\end{align*}
%
Using the template we define the constraints $\texttt{FindFunctions}(z,\lambda)$
that encodes the candidate functions that satisfy the activity requirements,
where $z$ is the vectors of parameters for encoding parameters
for each molecule,
and $\lambda$ limits the size of the candidate functions. 
%
We fix all other aspects of the VTS to be fixed via constraints
$\texttt{FixedForFunctions}$.
%
\begin{align*}
&\texttt{FindFunctions}(z,\lambda) =\\
&\Land \{ \bigwedge\limits_{i} n_{i,m} \limplies a_{i,m} = 
\texttt{NNFTemplate}([z_{m,1},..,z_{m,2\lambda}],[n_{i,1},\dots,n_{i,\mu}] ) \\
& \hspace{8cm}|
\nodef_m \text{ is undefined}\} \\
&\Land \{ \bigwedge\limits_{i,j,q} e_{i,j,q,m} \limplies b_{i,j,q,m} = 
\texttt{NNFTemplate}([z_{i,j,q,1},..,z_{i,j,q,2\lambda}],[e_{i,j,q,1},..,e_{i,j,q,\mu}] ) \\
& \hspace{8cm} | \edgef_m \text{ is undefined}
\}\\
& \texttt{FixedForFunctions} = \texttt{PresentCons} \land\\
& \quad \quad
\lnot \Lor \texttt{AbsentE} \;\union\; \texttt{AbsentELabel} \;\union\;
\texttt{AbsentNLabel} \;\union\;
\texttt{AbsentP}\\
&\texttt{SynthFunction}(z,\lambda) = \\
& \quad
(  \texttt{Consistancy}\land \texttt{Property} \land
\texttt{FixedForFunctions} \land \texttt{FindFunctions}(slimit) )
\end{align*}
We construct $\texttt{SynthFunction}(z,\lambda)$ similar to the earlier
variations.
%
By reading of the values of $z$ in a satisfying model of the formula,
we learn the synthesized function.

\subsubsection{Fixing VTS by both adding/deleting parts}
%
Now we will consider repairing of VTS by allowing not only addition but also
deletion of the molecules, edges, functions, or pairing matrix.
%
We have encoded the repairing in our tool by introducing flip bits
for each variable that is modifiable in the VTS.
%
We illustrate the repairing on one class of variables and rest can be
easily extended.
%
Let us consider repairing of node labels.
%
For each bit $n_{i,m}$, we create a bit $flip_{i,m}$.
%
We add constraints that take xor of VTS assigned values for  $n_{i,m}$
and $flip_{i,m}$.
%
We also limit the number of $flip_{i,m}$ that can be true, therefore
limiting the number of flips.
%
The above constraints are encoded in $\texttt{FlipN}(slimit)$.
\begin{align*}
&\texttt{FlipN}(slimit,flip) = \Land \{n_{i,m}\lxor flip_{i,m}| m \in \nlabel(i) \land i \in \nodes \} \land \\
& \quad \quad \quad
\Land \{ \lnot n_{i,m}\lxor flip_{i,m}| m \not \in \nlabel(i) \land i \in \nodes \} \land  \sum\limits_{i,m} flip_{i,m} \leq slimit
\end{align*}
%
Similar to the earlier variations, we construct
$\texttt{SynthRepairNode}(slimit)$ for the repair.
%
In that, $\texttt{FixedForNodeRepair}$ encodes all the parts of VTS that do not change.
\begin{align*}
% \\ 
& \texttt{FixedForNodeRepair} =  \texttt{PresentE} \land  
\texttt{PresentP} \land \texttt{KnownActiveE} 
\land \\
& \quad \texttt{UnknownActive} \land \texttt{KnownActiveN} \land \lnot 
\Lor \texttt{AbsentE} \;\union\; \texttt{AbsentNLabel} \;\union\;
\texttt{AbsentP}\\
&\texttt{SynthRepairNode}(slimit,flip) = \\
& \quad\quad
(  \texttt{Consistancy}\land \texttt{Property} \land
\texttt{FixedForNodeRepair} \land \texttt{FlipN}(slimit,flip) )
\end{align*}
A satisfying model of $\texttt{SynthRepairNode}(slimit,flip)$ will assign some
$flip$ bits to true.
We will learn from the assignments the needed modifications in the VTS. 

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
               
