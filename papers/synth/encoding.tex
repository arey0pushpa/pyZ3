In this section, we will present a list of problems that may arise from
synthesis of VTSs from partial available information
and our method for completing the missing parts.

\subsection{Problem Statements}

We will assume that we are given a VTS, whose all components
are not specified.
%
Our objective is to find the missing parts.
%
The missing information can be in any of these combinations parts of
VTS. For example existence of some undiscovered edges or nodes, or
insufficient knowledge about the presence of molecules in some part of
the VTS (either on the node or on the edge).
%
To cover most of the likely variations of this missing information we
have encoded the following variants of VTS synthesis.

\begin{enumerate}
\item  Add new edges 
\item  Modify the flow of molecules on the nodes and on the edges.
  % \begin{enumerate}
  % \item use available set of molecules.
  % \item allow new molecule type to be added.     
  % \end{enumerate}        
\item Learning meaningful activity functions from a given language of
  propositional formulas
  % \begin{enumerate}
  %   \item kcnf: low depth circuit.
  %   \item Boolean gates: And, Or.
  %   \item Boolean gates with linear combination.  
  % \end{enumerate}        
  % - Function dependence with var occurring once.
\item  VTS repair. Allow both delete and add to the system.
\end{enumerate}


\subsection{Encoding Incomplete VTS}

In our synthesis method, we take a VTS $G =
(\nodes,\mols,\edges,\nlabel,\pairs,\edgef,\nodef)$ as input.
%
We allow activity functions not to be specified, i.e., vectors
$\edgef$ and $\nodef$ may contain uninterpreted Boolean functions.
%
We construct the following constraints to encode the available information
about $G$.
%
\begin{align*}
  \texttt{KnownE} &= \land \{e_{i,j,q,m}|(i,M_1,j),...,(i,M_{q'},j) \in \edges \land q \leq q' \land m \in M_q \}\\
  \texttt{KnownN} &= \land \{n_{i,m}| m \in \nlabel(i) \land i \in \nodes \}\\
  \texttt{KnownP} &= \land \{p_{i,j}| (i,j) \in \pairs \} \\
  \texttt{KnownActiveN} &= \land \{ a_{i,m} = \nodef_m (n_{i,1},\dots,n_{i,\mu}) | \nodef_m \text{ is defined.} \} \\
  \texttt{KnownActiveE} &= \land \{ b_{i,j,q,m} = \edgef_m(e_{i,j,q,1}, .., e_{i,j,q,\mu})
                   | \edgef_m \text{ is defined.} \} \\
  \texttt{KnownCons} & = \texttt{KnownE} \land \texttt{KnownN} \land 
 \texttt{KnownP} \land \texttt{KnownActiveE} \land \texttt{KnownActiveN}
\end{align*}
We also collect the variables that are not set to true in $\texttt{KnownCons}$.
\begin{align*}
  \texttt{UnknownELabel} &=
  \{e_{i,j,q,m}|(i,M_1,j),...,(i,M_{q'},j) \in \edges \land 
                          0 < q \leq q' \land m \not\in M_{q} \}\\
  \texttt{UnknownE} &= \{e_{i,j,q}|(i,M_1,j),...,(i,M_{q'},j) \in \edges \land 
                    q' < q \leq \pi \}\\
  \texttt{UnknownNLabel} &= \{n_{i,m}| m \not\in \nlabel(i) \land i \in \nodes \}\\
  \texttt{UnknownP} &= \{p_{i,j}| (i,j) \not\in \pairs \} \\
  \texttt{UnnownActive} &=  \Land \{ a_{i,m} = \nodef_m (n_{i,1},\dots,n_{i,\mu}) | \nodef_m \text{ is undefined.} \} \union \\
   &\quad\quad\quad  \{ b_{i,j,q,m} = \edgef_m(e_{i,j,q,1}, .., e_{i,j,q,\mu})
                   | \edgef_m \text{ is undefined.} \}
\end{align*}
We have defined $\texttt{UnknownE}$, $\texttt{UnknownN}$, and
$\texttt{UnknownP}$
as set and will be converted into formulas depending
on the different usage in the synthesis problems. 

% Since not all the activity functions are defined some of the functions
% appearing in $\texttt{ActiveE}$ and $\texttt{ActiveN}$ are
% uninterpreted function symbols.

\subsection{Encoding synthesis property}

We will do synthesis against the following property that says the VTS
is stable and 3-connected, but not 4-connected.
%
The property is designed to balance the search space such that the synthesis procedure does not
succeed with simply adding too many edges. 
%
\begin{align*}
  \texttt{Property} =  \texttt{Stability} \land \texttt{Connected}(3) \land \texttt{DisConnected}(4)
\end{align*}

\subsection{Encoding synthesis constraints}

Now we will consider the encodings for  the above
listed synthesis problems.
%
The presented variations represent the encodings
supported by our tool.
%
Additionally, the combinations of the variation are also possible and
our tool easily supports them.
%
For simplicity of the presentation, we assume that if we are
synthesizing an aspect of VTS, then all other aspects are fully given.
%
Therefore, we will describe two kinds of constraints for synthesis
problems.
%
The first will encode the variable part in the synthesis problem and
the other encodes the fixed parts.
%
Subsequently, the two constraints will be put together with 
$\texttt{Consistancy}$ and 
$\texttt{Property}$.

\subsubsection{Fixing VTS by adding edges}
%
Now we will consider the case when we add new edges to VTS to satisfy the properties.
%
In the following, the pseudo-Boolean formula $\texttt{AddE}$ encodes
that at most $slimit$ new undeclared edges may be added in the VTS.
%
\texttt{FixedForEdge} encodes the parts of the VTS that do not change.
\begin{align*}
  &\texttt{AddE}(slimit) = \sum~\texttt{UnknownE} \leq slimit\\
  &\texttt{FixedForEdge} = \texttt{KnownCons} \land \texttt{UnknownActive} \land\\
   & \quad\quad\quad\quad \lnot \Lor \texttt{UnknownELabel} \;\union\;
                    \texttt{UnknownNLabel} \;\union\;
                    \texttt{UnknownP}
\end{align*}
We put together the constraints and obtain the following formula.
\begin{align*}
  & \texttt{SynthE}(slimit) =
     (  \texttt{Consistancy}\land \texttt{Property} \land
   \texttt{FixedForEdge} \land
  \texttt{AddE}(slimit) )
  % \tag{SynthE}\label{eq:addedge1}
\end{align*}
As we have seen $\texttt{Consistancy}$ encodes the basic constraints about VTS,
$\texttt{Property}$ encodes the goal, and
the rest two are just defined constraints.
%
A satisfying model of $\texttt{SynthE}$ will represent the synthesized VTS.
%
In the later synthesis problems, we will construct a similar QBF
formula with same first two parts and the last two are due the
requirements of the synthesis problem.

We limit the addition of the edges, since we look for a fix that require minimum number
of changes in the given VTS.
%
We start with $slimit = 1$ and grow one by one until $\texttt{SynthE}(slimit)$
becomes satisfiable.

\paragraph{\bf Fixing VTS by adding molecules to the labels:}
The system may also be fixed only by modifying labels on the edges or the nodes instead
of adding edges.
%
In the following, the formula encodes that only $slimit$ edge labels may be added.
\begin{align*}
  &\texttt{AddLabelEdge}(slimit) = 
    \sum~\texttt{UnknwonEdgeLabel}  \leq slimit\\
  & \texttt{FixedForLabel} = \texttt{KnownCons} \land \texttt{UnknownActive} \land\\
  & \quad \quad \lnot \Lor \texttt{UnknownE} \;\union\;
                    \texttt{UnknownNLabel} \;\union\;
                    \texttt{UnknownP}\\
  &\texttt{SynthLabel}(slimit) = \\
  & \quad\quad
    (  \texttt{Consistancy}\land \texttt{Property} \land
   \texttt{FixedForLabel} \land \texttt{AddLabelEdge}(slimit) )
\end{align*} 
Similar to the previous encoding we solve the
satisfiability of the above formula to obtain additional molecules
that may be added to the node labels.



\subsubsection{Fixing VTS by learning activity functions:}

Now we consider a scenario where some of the activity functions for some of the molecules
are missing.
%
The activity functions are $\mu$-input Boolean functions.
%
We choose a class of formulas for the candidate functions.
%
We encode the candidates in a formula with parameters.
%
We choose different candidates by choosing values for the parameters.


In the following, the formula \texttt{NNFTemplate} encodes a set of
negation normal form functions that take $y_1,..,y_\mu$ as input and
contain $\lambda$ literals.
%
We use $\texttt{Gate}$ to encode a gate that takes a parameter integer
$x$ to encode various gates.
%
We use $\texttt{Leaf} $ to encode the literal at some position.
%
Both are stitched to define \texttt{NNFTemplate}.
%
To encode the set of NNF formulas with $\lambda$ literals, it has
finite-range integer variables
$z_1,..,z_{2\lambda}$ as parameters.

% \paragraph{Encoding low depth cnf circuits}
% \paragraph{Encoding boolean gates}

\begin{align*}
  &\texttt{Gate}( x, w_1, w_2 ) = ( x  = 1 \limplies w_1  \land w_2 ) \land  
  ( x = 2  \limplies w_1  \lor w_2 ) \land
  ( x = 3  \limplies w_1 ) \land ...\\
  &\texttt{Leaf}( x, [y_1,..,y_\mu] ) =
  \Land\limits_{l=1}^{\mu} ( x = 2l-1  \limplies y_{l}) \land ( x = 2l  \limplies \lnot y_{l})\\
  &\texttt{NNFTemplate}([z_1,..,z_{2\lambda}],[y_1,..,y_\mu] ) = \\
  &\exists w_1,..,w_{2\lambda}.\;w_1 \land \Land_{l=1}^{\lambda} w_{\lambda+l} = \texttt{Leaf}( z_{\lambda+l}, [y_1,..,y_\mu] ) \land
  w_{l} = \texttt{Gate}( z_l, w_{2l},w_{2l+1})
\end{align*}

Using the template we define the constraints $\texttt{FindFunctions}(z,\lambda)$
that encodes the candidate functions that satisfy the activity requirements,
where $z$ is the vectors of parameters for encoding parameters
for each molecule,
and $\lambda$ limits the size of the candidate functions. 
%
We fix the all other aspect of the VTS to be fixed via constraints
$\texttt{FixedForFunctions}$.
%
\begin{align*}
  &\texttt{FindFunctions}(z,\lambda) =\\
  &\Land \{ \bigwedge\limits_{i} n_{i,m} \limplies a_{i,m} = 
  \texttt{NNFTemplate}([z_{m,1},..,z_{m,2\lambda}],[n_{i,1},\dots,n_{i,\mu}] ) |
  \nodef_m \text{ is undefined}\} \\
  &\Land \{ \bigwedge\limits_{i,j,q} e_{i,j,q,m} \limplies b_{i,j,q,m} = 
  \texttt{NNFTemplate}([z_{i,j,q,1},..,z_{i,j,q,2\lambda}],[e_{i,j,q,1},..,e_{i,j,q,\mu}] ) | 
  \edgef_m \text{ is undefined}
  \}\\
  & \texttt{FixedForFunctions} = \texttt{KnownCons} \land\\
  & \quad \quad
\lnot \Lor \texttt{UnknownE} \;\union\; \texttt{UnknownELabel} \;\union\;
                    \texttt{UnknownNLabel} \;\union\;
                    \texttt{UnknownP}\\
  &\texttt{SynthFunction}(z,\lambda) = \\
  & \quad\quad
    (  \texttt{Consistancy}\land \texttt{Property} \land
   \texttt{FixedForFunctions} \land \texttt{FindFunctions}(slimit) )
\end{align*}
We construct $\texttt{SynthFunction}(z,\lambda)$ similar to the earlier
variations.
%
By reading of the values of $z$ in a satisfying model of the formula,
we learn the synthesized function.

\subsection{Repairing VTS:}
%
Now we will consider the repair of VTS by allowing not only addition but also
deletion of the molecules, edges, functions, or pairing matrix.
%
We have encoded the vts repair in our tool by introducing flip bits
for each variable that is modifiable in the VTS.
%
We illustrate the repairing on one class of variables and rest can be
trivially extended.
%
Let us consider repairing of node labels.
%
For each bit $n_{i,m}$, we create a bit $flip_{i,m}$.
%
We add constraints that take xor of VTS assigned values for  $n_{i,m}$
and $flip_{i,m}$.
%
We also limit how many times the $flip_{i,m}$ can be true, therefore
limiting the number of flips.
%
Similar to the earlier variations, we construct
$\texttt{SynthRepairNode}(slimit)$ for the repair.
% 
\begin{align*}
    &\texttt{FlipN}(slimit) = \Land \{n_{i,m}\lxor flip_{i,m}| m \in \nlabel(i) \land i \in \nodes \} \land \\
  & \quad \quad \quad
    \Land \{ \lnot n_{i,m}\lxor flip_{i,m}| m \not \in \nlabel(i) \land i \in \nodes \} \land  \sum\limits_{i,m} flip_{i,m} \leq slimit \\
% \\  
    & \texttt{FixedForNodeRepair} =  \texttt{KnownE} \land  
      \texttt{KnownP} \land \texttt{KnownActiveE} \land \texttt{KnownActiveN}
      \land \\
  & \quad \quad \texttt{UnknownActive} \land \lnot 
    \Lor \texttt{UnknownE} \;\union\; \texttt{UnknownNLabel} \;\union\;
    \texttt{UnknownP}\\
  &\texttt{SynthRepairNode}(slimit) = \\
  & \quad\quad
    (  \texttt{Consistancy}\land \texttt{Property} \land
    \texttt{FixedForNodeRepair} \land \texttt{FlipN}(slimit) )
\end{align*}


% We encode the \texttt{ModifyCons} by putting the constraints on the
% unassigned edges and edge labels. The constraint of allowing only
% certain number of addition to the given VTS is encoded as
% \texttt{AtMostK} function over the unassigned edges and label.

%\[Unassigned Edges\]}
%\[Unassigned Activity Labels\]} 
%\[Unassigned Molecule Labels\]
% \begin{align}
%    \texttt{EdgeConstraint} = \texttt{AtMostk} \, [ \texttt{unassigned\_edges} ]  
%    \tag{E2}\label{eq:addedge2}
% \end{align}
% \begin{align}
%    \texttt{EdgeActivity} = \texttt{AtMostK} \, [ \texttt{activity\_labels} ]
%    \tag{E3}\label{eq:addedge3}
% \end{align}

% \begin{align}
%    \texttt{EdgePresence} = \texttt{AtMostK} \, [ \texttt{unassigned\_molecule\_labels} ]  
%    \tag{E4}\label{eq:addedge4}
% \end{align}



% Put \ref{eq:addedge2} in symbolic form and explain it in a couple of lines.

% In order to decrease the search space we do not allow any modification in the node label and activity on the nodes. This constraint can be encoded as the fixing all the unassigned bits to false. 
    
% %    // Fix rest of them to zero.
% %    auto fixVar0 = ! z3::mk_or ( openN )  && ! z3::mk_or ( openActiveN );

% \begin{align}
%   \exists i, j, q \,
%   ( \texttt{KConnectivity}  \land \texttt{NoSelfEdge} \land \ref{eq:addedge1} )    
%   \tag{E5}\label{eq:addedge5}
% \end{align}


% The \texttt{KConnectivity} and \texttt{NoSelfEdge} are same as the previous section, describing the graph to be a k but not k+1 connected and self edges are not allowed in the VTS. addedge1 is the constraint of \ref{eq:addedge1}.

%{i,j,m,p} r_{i,j,m,p} \limplies (\bigvee_{q} \, e_{i,j,q,m} \lor \bigvee_{i\neq i^{\prime}} ( \, \bigvee_{q} e_{i,i^{\prime},q,m}) \land r_{i^{\prime},j,m,p-1} )

    
 %   auto addConstraints = edgeC \&\& edgeActivityC \&\& edgePresenceC  \&\& fixVar0;

% %   auto qvtsCons = exists( setN, 
%                    exists( setActiveN, 
%                    exists( setPresenceE,  
%                    exists( setActiveE, 
%                    exists( setPairingM, 
%                    exists( setReach, 
%                            vtsCons \&\& vtsActivity \&\& inputCons \&\& addConstraints ))))));   


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
