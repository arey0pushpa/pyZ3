In this section, we will present a list of problems that may arise from
synthesis of VTSs from partial available information
and our method for completing the missing parts.

\subsection{Problem Statements}

We will assume that we are given a VTS, whose all components
are not specified.
%
Our objective is to find the missing parts.
%
The missing information can be in any of these combinations parts of
VTS. For example existence of some undiscovered edges or nodes, or
insufficient knowledge about the presence of molecules in some part of
the VTS (either on the node or on the edge).
%
To cover most of the likely variations of this missing information we
have encoded the following variants of VTS synthesis.

% % We will consider several variations of the problem.
% %
% \begin{itemize}
% \item Learning activity functions
% \item Modifying labels of the nodes and edges
% \item Adding missing edges
% \item Adding 
% \end{itemize}

%Types of questions we are trying to solve.

%
%
\begin{enumerate}[label=\Alph*]
\item  Add new edges to the given VTS to achieve graph stability, fusion and k connected. 
\item  Modify the flow of molecules on the nodes and on the edges.
  \begin{enumerate}
  	\item use available set of molecules.
    \item allow new molecule type to be added.     
  \end{enumerate}        
\item Learning meaningful activity functions from a given language of
  propositional formulas
  \begin{enumerate}
    \item kcnf: low depth circuit.
    \item Boolean gates: And, Or.
    \item Boolean gates with linear combination.  
    \end{enumerate}        
  % - Function dependence with var occurring once.
\item  VTS repair. [Allow both delete and add to the system]
\end{enumerate}


\subsection{Encoding Incomplete VTS}

In our synthesis algorithm, we take a VTS $G =
(\nodes,\mols,\edges,\nlabel,\pairs,\edgef,\nodef)$ as input.
%
We allow activity functions not to be specified, i.e., vectors
$\edgef$ and $\nodef$ may contain uninterpreted Boolean functions.
%
We construct the following constraints to encode the available information
about $G$.
%
\begin{align*}
  \texttt{KnownE} &= \land \{e_{i,j,q,m}|(i,M_1,j),...,(i,M_{q'},j) \in \edges \land q \leq q' \land m \in M_q \}\\
  \texttt{KnownN} &= \land \{n_{i,m}| m \in \nlabel(i) \land i \in \nodes \}\\
  \texttt{KnownP} &= \land \{p_{i,j}| (i,j) \in \pairs \} \\
  \texttt{KnownActiveN} &= \land \{ a_{i,m} = \nodef_m (n_{i,1},\dots,n_{i,\mu}) | \nodef_m \text{ is defined.} \} \\
  \texttt{KnownActiveE} &= \land \{ b_{i,j,q,m} = \edgef_m(e_{i,j,q,1}, .., e_{i,j,q,\mu})
                   | \edgef_m \text{ is defined.} \} \\
  \texttt{KnownCons} & = \texttt{KnownE} \land \texttt{KnownN} \land 
                      \texttt{KnownP} \land \texttt{KnownActiveE} \land \texttt{KnownActiveN}
\end{align*}
We will do synthesis against the following property that says the VTS is stable and  3-connected,
but not 4-connected.
%
The property is designed to balance the search space such that the synthesis procedure does not
succeed with simply adding too many edges. 
%
\begin{align*}
  \texttt{Property} =  \texttt{Stability} \land \texttt{Connected}(3) \land \texttt{DisConnected}(4)
\end{align*}


Now we will consider the constraints for synthesis for the above
listed problems.
\begin{align*}
  \texttt{UnknownE} &= \{e_{i,j,q}|(i,M_1,j),...,(i,M_{q'},j) \in \edges \land 
                      q' < q \leq \pi \}\\
  \texttt{SynthE} &= \Sigma \texttt{UnknownE} \leq 3 \\
\end{align*}


\begin{align}
  \exists n, a, e, b, p
  ( \texttt{Consistancy}\land \texttt{Property} \land
  \texttt{KnownCons} \land \texttt{SynthCons} )
  \tag{E1}\label{eq:addedge1}
\end{align}




% \begin{align}
%   \exists n_{i_k} \, a_{i_k} \, e_{ijqk} \, b_{ijqk} \, p_{k_{k^{-}}} \,  r_{i_j} \, 
%                ( basic_vts_constraints \land  vts\_activity\_constraint \land  given\_vts\_information \land  restriction\_on\_modification )   
%   \tag{E1}\label{eq:addedge1}
% \end{align}

% The basicvtsconstraints and vtsactivityconstraint are same as the
% previous sections, describing stability of the graph and fusion of the
% edge into the node and the molecular activity describing the active
% state of a molecule.The givenvtsinformation is encoded using a front
% end input language. The user provides the information of the VTS with
% a partial information using this front end. Our tool then converts
% these inputs into the constraints over the given VTS. 

We encode the restriction\_on\_modification by putting the constraints
on the unassigned edges and edge labels. The constraint of allowing
only certain number of addition to the given VTS is encoded as
at\_most\_k() function over the unassigned edges and label.

\begin{align}
    constraint on edge = atmost\_k\_allowed ( unassigned edges in VTS )    
    constraints of the molecular activity on the edge = at\_most\_k ( unassigned activity labels in VTS edges )
    constraints of the molecule presence on the edge = at\_most\_k ( unassigned molecule labels in VTS edges )\label{eq:addedge2}
\end{align}

Put \ref{eq:addedge2} in symbolic form and explain it in a couple of lines.

In order to decrease the search space we do not allow any modification in the node label and activity on the nodes. This constraint can be encoded as the fixing all the unassigned bits to false. 
    
%    // Fix rest of them to zero.
%    auto fixVar0 = ! z3::mk_or ( openN )  && ! z3::mk_or ( openActiveN );

\begin{align}
 \exists e_{ijq} ( connectivity\_constraint && self\_edge\_restriction && \ref{eq:addedge1} )    
  \tag{E1}\label{eq:addedge2}
\end{align}


The connectivity\_constraint \&\& self\_edge\_restriction are same as the previous sections, describing the graph to be a k but not k+1 connected and self edges are not allowed in the VTS. addedge1 is the constraint of \ref{eq:addedge1}.

%{i,j,m,p} r_{i,j,m,p} \limplies (\bigvee_{q} \, e_{i,j,q,m} \lor \bigvee_{i\neq i^{\prime}} ( \, \bigvee_{q} e_{i,i^{\prime},q,m}) \land r_{i^{\prime},j,m,p-1} )

    
    auto addConstraints = edgeC \&\& edgeActivityC \&\& edgePresenceC  \&\& fixVar0;

    auto qvtsCons = exists( setN, 
                    exists( setActiveN, 
                    exists( setPresenceE,  
                    exists( setActiveE, 
                    exists( setPairingM, 
                    exists( setReach, 
                            vtsCons \&\& vtsActivity \&\& inputCons \&\& addConstraints ))))));   

 
\subsection{Encoding molecules presence}

\subsection{Encoding low depth cnf circuits}

\subsection{Encoding boolean gates}

\subsection{Encoding vts repair}
The repair of the VTS requires both the addition and the deletion of the present molecules, node molecules pairing matrix and activity of the molecules. We have encoded the vts repair in our tool using the dummy xor bits.


\subsection{QBF encodings}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
