In this section, we will formally define VTSs as a labelled graph
and the conditions on the graphs that are discussed in the previous
section.
Subsequently, we will present the SAT encoding of the search problems
for the graphs that satisfies the conditions.

\subsection{Model}

We model VTSs as labelled directed graphs.
The graph labels both edges and labels with sets of molecules to denote
the set of molecules present in the node.
The graph is formally defined as follows.

\begin{df}
  A VTS $G$ is tuple $(\nodes,\mols,\edges,\nlabel,\pairs,\edgef,\nodef)$, where
  \begin{itemize}
  \item $\nodes$ is a set of nodes representing compartments in the VTS,
  \item $\mols$ is the set of molecules flowing in the network, 
  \item $\nlabel : \nodes \maps \powerset{\mols}$ defines the molecules present in the nodes  
  \item $ \nodes \times (\powerset{\mols}-\emptyset) \times \nodes \subseteq \edges$ is the set of edges
    with molecule sets as labels
  \item $\pairs : \mols \times \mols$ is pairing relating
  \item $\nodef : \mols \maps \powerset{\mols} \maps \booleans$ is activity maps for nodes
  \item $\edgef : \mols \maps \powerset{\mols} \maps \booleans $ is activity maps for edges
  \end{itemize}
\end{df}
$\pairs$ defines which molecules can fuse with which molecules.
%
Let $\pairs(M')$ denote $\{m|(m,m') \in P \text{ and } m' \in M'\}$.
%
$\nodef$ and $\edgef$ are used to define activity of molecules on
nodes and edges.
%
A molecule $k$ is {\em active} at node $n$ if $k \in \nlabel(n)$ and
$\nodef(k,\nlabel(n))$ is true.
%
A molecule $k$ is {\em active} at edges $(n,M',n')$ if $k \in M'$ and
$\edgef(k,M')$ is true.
%
\ashu{define missing conds V1-V7}

We will also consider several variations of the model.
%
For example, unique edge between two nodes, activity of molecules is
not constrained by $\nodef$ and $\edgef$, and \ashu{other
variations?}.
%

A {\em path} in $G$ is a sequence $n_1,...,n_\ell$ of nodes 
such that $(n_i,\_,n_{i+1}) \in \edges$ for each $ 0 < i < \ell$.
%
For a molecule $m \in M$,
An {\em $m$-path} in $G$ is a sequence $n_1,...,n_\ell$ of nodes 
such that $(n_i,M',n_{i+1}) \in \edges$ and $m \in M'$ for
each $ 0 < i < \ell$.
%
A node $n'$ is {\em reachable} from node $n$ in $G$ if there is a path
$n,...,n'$ in $G$.
%
A node $n'$ is {\em $m$-reachable} from node $n$ in $G$ if there is a
$m$-path $n,...,n'$ in $G$.
%
We call $G$ {\em stable} if for each $(n,M',n') \in \edges$ and $m \in M'$,
$n$ is $m$-reachable from $n'$.
%
An edge $(n,M',n') \in \edges$ {\em fuses} with its destination node $n'$
if there are molecules $m,m' \in \mols$ such that $m$ is active in
$(n,M',n')$, $m'$ is active in $n'$, and $(m,m') \in \pairs$.
%
We call $G$ {\em well-fused} if each edge $(n,M',n') \in \edges$ fuses
with non-empty fusing molecules $M'' \subseteq M'$
and $\pairs(M'')$ are not active in any other node.



%
We call $G$ {\em connected} if for each $n,n' \in \nodes$,
$n'$ is reachable from $n$ in $G$.
%
We call $G$ $k$-connected if for each $E' \subseteq \edges$ and $|E'| < k$,
VTS $(\nodes,\mols,\edges-E',\nlabel,\pairs,\edgef,\nodef)$ is connected.


\paragraph{Search problem}

Based upon earlier discussion, we need to answer the following search
question for ......\ashu{match with the earlier text}
For a given $k$, size $\nu$, and molecule number $\mu$,
we are searching for stable and well-fused VTS
$G = (\nodes,\mols,\edges,\nlabel,\pairs,\edgef,\nodef)$ such that
$|\nodes| = \nu$, $|\mols = \mu|$, and
$G$ is not $k$-connected.    


\subsection{Boolean satisfiability of the search problem}

We translate the search problem into a Boolean satisfiability
problem and use SAT solvers to find the satisfying VTSs.
%
We will first present the variables used to encode the
VTSs and the properties.
%
Afterwards, we will present the formulas corresponding to the
properties.

\subsubsection{Variables for VTS description}
%
We assume that size of the graph is $\nu$ and number of molecules is
$\mu$.
%
Furthermore, we also limit the maximum number $\pi$ of edges present
between two nodes.
%
Here, we list the vector of Boolean variables and uninterpreted function symbols
that encode the VTSs.
\begin{enumerate}

\item Boolean variable $n_{i,m}$ indicates if $m \in \nlabel(i)$
\item Boolean variable $e_{i,j,q}$ indicates if $q$th edge exists between $i$ and $j$.
\item Boolean variable $e_{i,j,q,m}$ indicates if $q$th edge between $i$ and $j$ contains molecule $m$.

\item Boolean variable $p_{k,k'}$ indicates if $(m,m') \in \pairs$
\item uninterpreted Boolean functions $\nodef_m : \booleans^\mu \maps \booleans$
encoding $\nodef(m)$ map
\item uninterpreted Boolean functions $\edgef_m : \booleans^\mu \maps \booleans$
encoding $\edgef(m)$ map
\end{enumerate}

We also have auxiliary variables that will help us encode the properties 
\begin{enumerate}
\item $a_{i,m}$ indicates that molecule $m$ is active at node $i$, i.e., $\nodef(m,L(i))$
  holds
\item $b_{i,j,q,m}$ indicates that molecule $m$ is active at $q$th edge $(i,M',j)$ between $i$ and $j$, i.e., $\edgef(m,M')$ holds
\item $r_{i,j,m,z}$ indicates that there is a path from $i$ to $j$ of length $z$
\item $d_{i,j,q}$ indicates $q$th edge between $i$ and $j$ is dropped(used in encoding
  $k$-connected property)
\end{enumerate}


% Every variable is a Boolean bit, for example, $n_{0,1}$ represents node 0
% with type 1 molecule present. Assignment to the Boolean variable
% n(0,1) to True will mean that at node 0 type 1 molecule is present. 

% Basic notation for the formula we are trying to generate.
% \begin{enumerate}

% \item edge = e(i,j,q)      
%       we will assign e(i,j,q) for a qth edge between node i and j.

% \item dump = d(i,j,q)
%       to represent drop of edge(i,j,q) from the graph we will use d(i,j,q).        
       
% \item presence node = n(i,k) 
% 	  kth molecule is present on the node i.
      
% \item active\_node = a(i,k) 
%       kth molecule is active on the node i.
      
% \item presence\_edge = e(i,j,q,k)
%       There is an qth edge between node i and j with kth molecule present.

% \item active\_edge = b(i,j,q,k)
%       There is an qth edge between node i and j with kth molecule active.

% \item reachability = r(i,j,k,z)
%       Node i and j are reachable with kth molecule present in z steps.

% \item pairing matrix = p(k,k')
%       Molecule k and k' are pairing molecules in the matrix.

% \item Type of the Boolean function = sorts (takes k-1 arguments Bool and return Bool) 
% \item Boolean function on nodes Function (fn\_{m},*sorts) 

% \item Boolean function on edge Function(fe\_{m},*sorts)

% \end{enumerate}


We will describe the Boolean formulas that encode VTSs in several categories.
%
In the end, we will present in a table the formulas needed for the
model variants.
%
To avoid cumbersome notation, we will not explicitly write the ranges of the indexing
in the formulas.
%
$i$ and $j$ will be ranged over nodes.
%
$m$ will be ranged over molecules.
%
$q$ will be ranged over edges between two nodes.
%

% \subsubsection{Constraints on the structure of the edges, nodes and }
\subsubsection{Constraints on presence, activity of the molecule, and pairing matrix}
%
We need the following constraints~\eqref{eq:f0} and~\eqref{eq:c3}
to encode the basic structure of VTSs.
%
For an edge to exist it should have one molecule present. 
%
\begin{align}
  \bigwedge\limits_{i,j,q} (\bigvee_m e_{i,j,q,m} )\limplies e_{i,j,q}\tag{V1}\label{eq:f0}
\end{align}

If a molecule is active on an edge, it should be present on the edge.
%
\begin{align}
  \bigwedge\limits_{i,j,q,m} b_{i,j,q,m} \limplies e_{i,j,q,m}\tag{V2}\label{eq:f1}
\end{align}

A molecule should be present to be active on a node.  
\begin{align}
  \bigwedge\limits_{i,m} a_{i,m} \limplies n_{i,m}
  \tag{V3}\label{eq:c4}
\end{align}

The edge labels are subset of the node label of source and target compartments.

\begin{align}
  \bigwedge\limits_{i,j,q,m} e_{i,j,q,m} \limplies n_{i,m}\tag{V4}\label{eq:c0}\\
  \bigwedge\limits_{i,j,q,m}  e_{i,j,q,m} \limplies n_{j,m}\tag{V5}\label{eq:c1}
\end{align}

%C1 =  e_ijk -> aik and e_ijk -> ajk

Self edges are not allowed. 

\begin{align}
   \bigwedge\limits_{i,q} \neg e_{i,i,q}\tag{V6}\label{eq:c2}
\end{align}

Condition on $p_{kk'}$. \ashu{why???} Diagonal blocks should be all 0's.

\begin{align}
  \bigwedge\limits_{(x < M/2 \, \land  \, y < M/2) \lor  (x >= M/2 \land y >= M/2)} \neg p(x,y)
  \tag{V7}\label{eq:c3}
\end{align}

\subsubsection{Well-fused constraints}
Boolean constraint~\eqref{eq:fuse1} encodes that each edge must fuse with
destination node.
%
Boolean constraint~\eqref{eq:fuse2} encodes the each should not be able to
potentially fuse with any other node.

% Fusion rules consist of two different mechanisms.
% \begin{enumerate}
% \item  A \textbf{pairing mechanism} which determines compatible Q-R pairs on vesicles and compartments that can cause fusion.
% \item \textbf{regulatory mechanisms} on the edges and nodes (possibly distinct) which regulates molecules activity based on the presence/absence of other molecules on the corresponding node or edge.
% \end{enumerate}
% Boolean constraint~\eqref{eq:fuse1} and~\eqref{eq:fuse2} are used to encode well-fused
% property.

% F4: For an edge to be valid, at least one SNARE pair on the vesicle and target compartment must be active and have a non-zero entry in the pairing matrix.  
\begin{align}
  \bigwedge\limits_{i,j,q} e_{i,j,q} \limplies \bigvee_{m,m^{\prime}} (b_{i,j,q,m} \land a_{j,m^{\prime}} \land p_{m,m^{\prime}})
  \tag{V8}\label{eq:fuse1}  \\
\bigwedge\limits_{i,j,q,m} b_{i,j,q,m} \limplies \neg \bigvee_{j \neq j^{\prime}, m^{\prime\prime}} ( a_{j^{\prime},m^{\prime\prime}} \land p_{m,m^{\prime\prime}})
  \tag{V9}\label{eq:fuse2}  
\end{align}

% F5: To ensure that fusion respects the graph structure by the edge under consideration, it should not be possible to fuse with any other node.


\subsubsection{Regulation on nodes and edges}
%
Regulation of the molecules is based on the kind of the model under
consideration.
%
For example, model 1 (-V 1) has two different arbitrary
Boolean functions dictating the activity of the molecules on edge and
nodes.
%
For variation 3 (-V 3) activity on edge is driven by pairing
inhibition.  

We use two Boolean variables A\_* to build these two constraints. \newline

A\_nn: No regulation on nodes i.e all the present molecules on the nodes are active.
\[
\bigwedge\limits_{i,m} n_{i,m} = a_{i,m} \,
\]  

A\_nb: Boolean regulation on nodes. Activity of a molecule k on the node is defined as a Boolean function of presence of other molecule present on that node.
\[ \bigwedge\limits_{i,k} n_{i,m} \limplies a_{i,m} =   f_m (n_{i,1},\dots,n_{i,\mu}) \, \]

A\_en: No regulation on edges i.e all the present molecules on the edges are active.
\[ \bigwedge\limits_{i,j,q,m} e_{i,j,q,m} = b_{i,j,q,m} \, \]    

A\_eb: Boolean regulation on edges. Activity of a molecule k on the node is defined as a Boolean function of presence of other molecule present on that node.
\[ \bigwedge\limits_{i,j,q,k} e_{i,j,q,k} \limplies b_{i,j,q,k} == f_e[k](\bigvee_{k' != k} e_{i,j,q,k'}) \, \]  

A\_ep: Pairing inhibition. The activity of the molecules is defined by inhibition by other molecules based on the pairing matrix. 
\[ \bigwedge\limits_{i,j,q, k}  (e_{i,j,q,k} \land [ ( \bigvee_{k'} p_{k,k'} \land \bigwedge_{k' != k} p_{k,k'} \limplies e_{i,j,q,k'})] ) \limplies \neg b_{i,j,q,k}) \, \]  

\[ \bigwedge\limits_{i,j, q, k}  (e_{i,j,q,k} \land \neg [ ( \bigvee_{k'} p_{k,k'} \land \bigwedge_{k' != k} p_{k,k'} \limplies e_{i,j,q,k'})] ) \limplies b_{i,j,q,k}) \, \]  


% - F0: b(i,j,k) $\limplies$ e(i,j,k)

\subsubsection{Constraints for stability condition}
The whole cell should be in stable condition i.e flow of the molecule is balanced at every point and globally. Each molecule leaving its source node on a vesicle should come back in a cycle. Boolean variable F3 and F2 are used to model these constraints. 

\textbf {Reachability definition and stability condition.}
We have encoded stable condition by using reachability definition. \newline

F3: Stability condition. For every leaving molecule, the source node is reachable from the target node with that molecule present, in maximum p steps. 

% I have implemented: Changed the implementation in code too.
%\[ \bigwedge\limits_{i,j,q,k} e_{i,j,q,k} \limplies (r_{j,i,k,0}  \lor r_{j,i,k,1} \lor ... \lor r_{j,i,k,p}) \, \]

% Update: Better 
\[ \bigwedge\limits_{i,j,k} (\bigvee_{q} e_{i,j,q,k}) \limplies (r_{j,i,k,0}  \lor r_{j,i,k,1} \lor ... \lor r_{j,i,k,p}) \, \]

F2: Reachability definition. Node j is reachable from node i with kth molecule present in maximum p steps if either there is a direct edge between i-j with that molecule present or there is a direct edge between $i^{\prime \prime}$ $(i != i^{\prime \prime})$ and j with kth molecule present on that edge and $i^{\prime \prime}$ are reachable from i in p steps. 

\[ \bigwedge\limits_{i,j,k,p} r_{i,j,k,p} \limplies (\bigvee_{q} \, e_{i,j,q,k} \lor \bigvee_{i\neq i^{\prime}} ( \, \bigvee_{q} e_{i,i^{\prime},q,k}) \land r_{i^{\prime},j,k,p-1} ) \, \]


\subsubsection{Graph connectivity constraints}
To check the whether that n connected is a necessary condition, we remove (drop) n edges from the graph and if it disconnects the graph and we get an assignment we have an n connected satisfying graph. We can go down or up using -C \_ option.  \newline 

D0: Only present edges can be dropped.
\[ \bigwedge\limits_{i,j,q} d_{i,j,q} \limplies e_{i,j,q}  \]

D1,D2: We are dropping c edges from the graph. exactly c are dropped.
\[ \sum_{i,j,q} d_{i,j,q} == c \]

D3:  Graph becomes disconnected. Ensure that there is no path between some nodes i,j in the underlying undirected graph. Different reachability.
\[ \bigwedge\limits_{i,j} \neg (r^{\prime}_{i,j} \lor r^{\prime}_{j,i})]  \]

D4: New reachability definition for graph connectedness: dReachable. Node i,j are reachable either if there is a direct edge and its not dropped or there is an node $i^{\prime}$ such that, there is a direct edge between i, $i^{\prime}$ which is not dropped and $i^{\prime}$ and j is dReachable.

\[ \bigwedge\limits_{i,j}  [\bigvee_{q} (e_{i,j,q} \land  \neg d_{i,j,q}) \lor  (\bigvee_{i' != i}  r^{\prime}(i',j) \land  \bigvee_{q} (e_{i,i',q} \land \neg d_{i,i',q}) ] \limplies r^{\prime}(i,j)  \]

\subsection{Creating a solver and solving these constraints}
We will create a solver and add these build formula using these constraints to that and then check whether there a satisfiable assignment that satisfies all these constraints.

\begin{figure}[ht]
%\vspace{-3mm}
\begin{verbatim}
# Create a solver
s = Solver()
# Add these formulas to it.
s.add(A0, A1, C0, C1, C2, C4, C5, F0, F1, F2, F3, F4, F5, D0, D1, D2, D3)

# Check for the satisfiability assignment.
print s.check()   
\end{verbatim}
\caption{Solving for these constraints.}
\label{code:motivate}
\end{figure} 


%--------------------- DO NOT ERASE BELOW THIS LINE --------------------------

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
